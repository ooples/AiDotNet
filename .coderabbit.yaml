# yaml-language-server: $schema=https://coderabbit.ai/integrations/schema.v2.json
language: en-US
tone_instructions: "Be thorough and aggressive about code quality. Flag ALL stubs, placeholders, TODO comments, simplified implementations, and non-production-ready code as BLOCKING issues. Focus on production readiness, architectural concerns, and API surface area."
early_access: true
enable_free_tier: true

reviews:
  profile: assertive
  request_changes_workflow: true
  high_level_summary: true
  high_level_summary_placeholder: "@coderabbitai summary"
  auto_title_placeholder: "@coderabbitai"
  review_status: true
  commit_status: true
  poem: true
  collapse_walkthrough: false
  sequence_diagrams: true
  changed_files_summary: true
  labeling_instructions: []
  path_filters: []
  path_instructions:
    - path: "src/**"
      instructions: |
        ## AiDotNet Architecture Guidelines

        This library uses the **Facade Pattern**. When reviewing code changes, apply these principles:

        ### Public API Surface (CRITICAL)
        - **Users should ONLY interact with `AiModelBuilder.cs` and `AiModelResult.cs`**
        - These are the facade classes that expose a clean, simple API
        - Any new public methods or classes that users might call directly should be scrutinized
        - Ask: "Does this need to be public, or can it be internal?"

        ### Access Modifier Guidelines
        - **Prefer `internal` over `public`** for plumbing/helper classes that users never instantiate or consume
        - **Prefer `private` over `internal`** when the member is only used within its own class
        - Helper classes, utilities, and implementation details should be `internal`

        ### Types That SHOULD Be Public (Do NOT suggest making these internal)
        - **Options classes** (`*Options`, `*Config`) - Users instantiate these to configure models, clustering, classifiers, etc.
        - **Model base classes** - Users may extend these or reference them
        - **Result/data types** returned from the facade - Users consume these
        - **Enum types** - Users pass these as configuration values
        - **Methods on base classes** (e.g., `GetOptions()`, `Train()`, `Predict()`) that users call directly
        - Any type that appears in a **public constructor parameter**, **public method parameter**, or **public property type**

        ### Types That Should Be Internal
        - Agent plumbing classes (parsers, registries, applicators)
        - Internal interfaces that only the library implements
        - Intermediate helper/utility classes
        - Validation result types used only internally

        ### Why This Matters
        1. **Simplicity**: Users get a clean API without overwhelming options
        2. **IP Protection**: Internal implementation details are hidden
        3. **Flexibility**: We can refactor internals without breaking changes
        4. **Maintainability**: Smaller public API surface = fewer breaking changes
        5. **Usability**: Users MUST be able to instantiate options and configure models

        ### Production Readiness (CRITICAL - Flag as BLOCKING)
        **Every PR must contain production-ready code. Flag ALL of the following as blocking issues requiring immediate fix:**

        - **Stubs/Placeholders**: Methods with `throw new NotImplementedException()`, empty method bodies, `// TODO` comments, placeholder return values (e.g., `return default;` when real logic is needed), or `// Future enhancement` comments
        - **Simplified implementations**: Code that takes shortcuts like hardcoded values instead of proper logic, missing error handling at system boundaries, missing validation of external inputs, or methods that just log/print instead of doing real work
        - **Incomplete features**: Half-implemented patterns where some code paths work but others silently do nothing, missing null checks on external data, or catch blocks that swallow exceptions without logging
        - **Non-production patterns**: Using `Console.WriteLine` for logging instead of proper logging abstractions, hardcoded file paths or connection strings, magic numbers without constants or configuration
        - **Dead code**: Commented-out code blocks, unreachable code paths, unused variables/parameters that suggest incomplete refactoring
        - **Test quality**: Tests that always pass regardless of implementation (e.g., conditional assertions that skip when things fail), tests with no meaningful assertions, test methods that are empty or only test trivial behavior

        **When you find ANY of the above, your review comment MUST:**
        1. Explicitly state this is a blocking issue
        2. Describe what production-ready code should look like instead
        3. Provide a concrete code suggestion for the fix

        ### Review Checklist
        - [ ] **BLOCKING**: No stubs, placeholders, TODOs, or NotImplementedException anywhere in the diff
        - [ ] **BLOCKING**: All methods have complete, production-ready implementations
        - [ ] **BLOCKING**: Tests have meaningful assertions that actually verify behavior
        - [ ] If suggesting `internal`, verify the type is NOT used in any public constructor, method parameter, or property
        - [ ] Options classes (`*Options`) should almost always be `public` since users instantiate them
        - [ ] Does the change maintain the facade pattern (users use AiModelBuilder/AiModelResult)?
        - [ ] Are implementation details (parsers, registries, applicators) properly hidden as internal/private?
        - [ ] Could this change prevent users from configuring or extending models?

    - path: "src/Interfaces/**"
      instructions: |
        ## Interface Review Guidelines

        Interfaces in this library serve different roles - some are internal plumbing, others are user-facing extension points.

        ### Key Principles
        - **Internal interfaces**: Plumbing interfaces that only the library implements (e.g., `IConfigurableModel`)
        - **Public interfaces**: Extension points where users may provide implementations, or interfaces used in public API signatures
        - `IOptimizer`, `IModel`, `IDataLoader` etc. are internal extension points
        - Adding methods to interfaces is a breaking change for any external implementations

        ### When Reviewing Interface Changes
        - Check if the interface appears in any public API signature - if so, it must be `public`
        - Interfaces only used internally by the library can be `internal`
        - Document breaking changes in PR description if modifying public interfaces
        - Consider if the change could be handled through the facade instead

    - path: "src/Optimizers/**"
      instructions: |
        ## Optimizer Review Guidelines

        Optimizers are **internal implementation details**. Users select optimizers through `AiModelBuilder` configuration, not by instantiating them directly.

        ### Key Principles
        - Optimizer classes should be `internal` or have internal constructors
        - Users configure optimizers via `AiModelBuilder.ConfigureOptimizer()` fluent API
        - Complex optimizer logic should be hidden from users

    - path: "tests/**"
      instructions: |
        ## Test Review Guidelines

        - Tests may need access to internal members via `[assembly: InternalsVisibleTo]`
        - Test classes implementing interfaces (like `IOptimizer`) need all interface methods
        - Prefer testing through the public facade (`AiModelBuilder`) when possible

        ### Test Quality (CRITICAL - Flag as BLOCKING)
        **Tests MUST be production-quality. Flag ALL of the following as blocking issues:**

        - **Always-passing tests**: Tests with conditional assertions that skip verification when things fail (e.g., `if (result != null) Assert.Equal(...)` - this passes even when result IS null)
        - **Missing assertions**: Test methods that call code but don't assert anything meaningful
        - **Trivial assertions**: Tests that only check `Assert.NotNull` when they should verify actual behavior/values
        - **Placeholder tests**: Tests with `// TODO: add assertions` or empty test bodies
        - **Duplicate coverage**: Multiple tests that verify the exact same thing with no variation

        **Good tests should:**
        - Have clear Arrange/Act/Assert structure
        - Assert specific expected values, not just non-null
        - Test edge cases and error conditions
        - Use unconditional assertions (the test should FAIL if behavior is wrong)

chat:
  auto_reply: true

knowledge_base:
  opt_out: false
  learnings:
    scope: auto
  issues:
    scope: auto
  jira:
    project_keys: []
  linear:
    team_keys: []
  pull_requests:
    scope: auto
