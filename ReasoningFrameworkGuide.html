<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>AiDotNet Reasoning Framework - Complete Guide | AiDotNet Documentation </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="AiDotNet Reasoning Framework - Complete Guide | AiDotNet Documentation ">
      
      
      <link rel="icon" href="favicon.ico">
      <link rel="stylesheet" href="public/docfx.min.css">
      <link rel="stylesheet" href="public/main.css">
      <meta name="docfx:navrel" content="toc.html">
      <meta name="docfx:tocrel" content="toc.html">
      
      <meta name="docfx:rel" content="">
      
      
      <meta name="docfx:docurl" content="https://github.com/ooples/AiDotNet/blob/master/docs/ReasoningFrameworkGuide.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="index.html">
            <img id="logo" class="svg" src="logo.svg" alt="AiDotNet">
            AiDotNet
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">

      <div class="content">
        <div class="actionbar">

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="aidotnet-reasoning-framework---complete-guide">AiDotNet Reasoning Framework - Complete Guide</h1>

<h2 id="overview">Overview</h2>
<p>The AiDotNet Reasoning Framework is a <strong>comprehensive system for advanced AI reasoning</strong> that implements state-of-the-art techniques from recent research papers and provides a complete toolkit for building reasoning systems.</p>
<h3 id="key-features">Key Features</h3>
<p>✅ <strong>Multiple Reasoning Strategies</strong></p>
<ul>
<li>Chain-of-Thought (CoT) - Step-by-step reasoning</li>
<li>Self-Consistency - Multiple sampling with voting</li>
<li>Tree-of-Thoughts (ToT) - Multi-path exploration</li>
</ul>
<p>✅ <strong>Verification &amp; Refinement</strong></p>
<ul>
<li>Critic models for quality evaluation</li>
<li>External tool verification (calculator, code execution)</li>
<li>Self-refinement loops based on feedback</li>
<li>Process Reward Models (PRM) for RL training</li>
</ul>
<p>✅ <strong>Advanced Components</strong></p>
<ul>
<li>Diversity sampling for varied exploration</li>
<li>Contradiction detection for logical consistency</li>
<li>Test-time compute scaling</li>
<li>Domain-specific reasoners (Math, Code)</li>
</ul>
<p>✅ <strong>Comprehensive Benchmarks</strong></p>
<ul>
<li>GSM8K (grade school math)</li>
<li>HumanEval (Python code generation)</li>
<li>Extensible benchmark infrastructure</li>
</ul>
<hr>
<h2 id="quick-start">Quick Start</h2>
<h3 id="1-basic-chain-of-thought-reasoning">1. Basic Chain-of-Thought Reasoning</h3>
<pre><code class="lang-csharp">using AiDotNet.Reasoning.Strategies;
using AiDotNet.Reasoning.Models;

// Create a chat model (example with OpenAI)
var chatModel = new OpenAIChatModel&lt;double&gt;(&quot;gpt-4&quot;);

// Create Chain-of-Thought strategy
var strategy = new ChainOfThoughtStrategy&lt;double&gt;(chatModel);

// Solve a problem
var result = await strategy.ReasonAsync(
    &quot;If a train travels 60 mph for 2.5 hours, how far does it go?&quot;,
    ReasoningConfig.Default()
);

// Access the answer and reasoning
Console.WriteLine($&quot;Answer: {result.FinalAnswer}&quot;);
Console.WriteLine($&quot;Confidence: {result.OverallConfidence}&quot;);

// See the reasoning steps
foreach (var step in result.ReasoningChain.Steps)
{
    Console.WriteLine($&quot;Step {step.StepNumber}: {step.Content}&quot;);
}
</code></pre>
<p><strong>Output:</strong></p>
<pre><code class="lang-text">Answer: 150 miles
Confidence: 0.95
Step 1: Calculate distance using the formula: distance = speed × time
Step 2: Multiply speed (60 mph) by time (2.5 hours)
Step 3: 60 × 2.5 = 150
Step 4: The train travels 150 miles
</code></pre>
<hr>
<h3 id="2-self-consistency-for-higher-reliability">2. Self-Consistency for Higher Reliability</h3>
<pre><code class="lang-csharp">using AiDotNet.Reasoning.Strategies;

var chatModel = new OpenAIChatModel&lt;double&gt;(&quot;gpt-4&quot;);
var strategy = new SelfConsistencyStrategy&lt;double&gt;(chatModel);

// Configure for multiple samples
var config = new ReasoningConfig
{
    NumSamples = 10,        // Try 10 different reasoning paths
    Temperature = 0.7       // Moderate diversity
};

var result = await strategy.ReasonAsync(
    &quot;A number is 15% less than another number. If the smaller number is 85, what is the larger number?&quot;,
    config
);

// See consensus
Console.WriteLine($&quot;Final Answer: {result.FinalAnswer}&quot;);
Console.WriteLine($&quot;Based on {result.AlternativeChains.Count} different reasoning paths&quot;);
Console.WriteLine($&quot;Consensus: {result.Metrics[&quot;consensus_ratio&quot;]:P}&quot;);
</code></pre>
<p><strong>Output:</strong></p>
<pre><code class="lang-text">Final Answer: 100
Based on 10 different reasoning paths
Consensus: 90% (9/10 paths agreed)
</code></pre>
<hr>
<h3 id="3-tree-of-thoughts-for-complex-problems">3. Tree-of-Thoughts for Complex Problems</h3>
<pre><code class="lang-csharp">using AiDotNet.Reasoning.Strategies;

var chatModel = new OpenAIChatModel&lt;double&gt;(&quot;gpt-4&quot;);
var strategy = new TreeOfThoughtsStrategy&lt;double&gt;(chatModel);

var config = new ReasoningConfig
{
    ExplorationDepth = 3,     // Explore 3 levels deep
    BranchingFactor = 3,      // Generate 3 alternatives per node
    BeamWidth = 5            // Keep top 5 paths
};

var result = await strategy.ReasonAsync(
    &quot;Design an efficient algorithm to find the longest palindromic substring in a string.&quot;,
    config
);

Console.WriteLine($&quot;Best approach: {result.FinalAnswer}&quot;);
Console.WriteLine($&quot;Explored {result.Metrics[&quot;nodes_explored&quot;]} different solution paths&quot;);
</code></pre>
<hr>
<h3 id="4-mathematical-reasoning-with-verification">4. Mathematical Reasoning with Verification</h3>
<pre><code class="lang-csharp">using AiDotNet.Reasoning.DomainSpecific;

var chatModel = new OpenAIChatModel&lt;double&gt;(&quot;gpt-4&quot;);
var mathReasoner = new MathematicalReasoner&lt;double&gt;(chatModel);

// Solve with verification
var result = await mathReasoner.SolveAsync(
    &quot;If Janet has 16 eggs, eats 3 for breakfast, and bakes 4 into muffins daily, &quot; +
    &quot;how many does she sell at $2 each?&quot;,
    config: ReasoningConfig.Default(),
    useVerification: true,      // Enable calculator verification
    useSelfConsistency: false
);

// Check if calculations were verified
Console.WriteLine($&quot;All calculations verified: {result.Metrics[&quot;all_calculations_verified&quot;]}&quot;);
Console.WriteLine($&quot;Answer: {result.FinalAnswer}&quot;);
</code></pre>
<p><strong>Output:</strong></p>
<pre><code class="lang-text">All calculations verified: True
Answer: Janet sells 9 eggs, making $18 daily
</code></pre>
<hr>
<h3 id="5-code-generation-with-reasoning">5. Code Generation with Reasoning</h3>
<pre><code class="lang-csharp">using AiDotNet.Reasoning.DomainSpecific;

var chatModel = new OpenAIChatModel&lt;double&gt;(&quot;gpt-4&quot;);
var codeReasoner = new CodeReasoner&lt;double&gt;(chatModel);

// Generate code with explanation
var result = await codeReasoner.GenerateCodeAsync(
    specification: &quot;A function that checks if a number is prime&quot;,
    language: &quot;python&quot;,
    config: ReasoningConfig.Default()
);

// Extract the code
string code = codeReasoner.ExtractCode(result.FinalAnswer);
Console.WriteLine(&quot;Generated Code:&quot;);
Console.WriteLine(code);

// See the reasoning
Console.WriteLine(&quot;\nReasoning Steps:&quot;);
foreach (var step in result.ReasoningChain.Steps)
{
    Console.WriteLine($&quot;- {step.Content}&quot;);
}
</code></pre>
<hr>
<h3 id="6-adaptive-compute-scaling">6. Adaptive Compute Scaling</h3>
<pre><code class="lang-csharp">using AiDotNet.Reasoning.ComputeScaling;

var scaler = new AdaptiveComputeScaler&lt;double&gt;();

// Easy problem
string easyProblem = &quot;What is 2 + 2?&quot;;
var easyConfig = scaler.ScaleConfig(easyProblem);
Console.WriteLine($&quot;Easy problem config: MaxSteps={easyConfig.MaxSteps}, Verification={easyConfig.EnableVerification}&quot;);

// Hard problem
string hardProblem = &quot;Prove that there are infinitely many prime numbers using Euclid's method.&quot;;
var hardConfig = scaler.ScaleConfig(hardProblem);
Console.WriteLine($&quot;Hard problem config: MaxSteps={hardConfig.MaxSteps}, Verification={hardConfig.EnableVerification}&quot;);
Console.WriteLine($&quot;Compute scaling: {hardConfig.ComputeScalingFactor}x&quot;);
</code></pre>
<p><strong>Output:</strong></p>
<pre><code class="lang-text">Easy problem config: MaxSteps=3, Verification=False
Hard problem config: MaxSteps=50, Verification=True
Compute scaling: 5.0x
</code></pre>
<hr>
<h3 id="7-running-benchmarks">7. Running Benchmarks</h3>
<pre><code class="lang-csharp">using AiDotNet.Reasoning.Benchmarks;
using AiDotNet.Reasoning.DomainSpecific;

// Setup
var chatModel = new OpenAIChatModel&lt;double&gt;(&quot;gpt-4&quot;);
var mathReasoner = new MathematicalReasoner&lt;double&gt;(chatModel);
var benchmark = new GSM8KBenchmark&lt;double&gt;();

// Create evaluation function
Func&lt;string, Task&lt;string&gt;&gt; evaluator = async (problem) =&gt;
{
    var result = await mathReasoner.SolveAsync(
        problem,
        useVerification: true,
        useSelfConsistency: false
    );
    return result.FinalAnswer;
};

// Run benchmark on sample
var results = await benchmark.EvaluateAsync(
    evaluator,
    sampleSize: 50  // Evaluate 50 problems
);

// Display results
Console.WriteLine(results.GetSummary());
</code></pre>
<p><strong>Output:</strong></p>
<pre><code class="lang-text">Benchmark: GSM8K
Problems Evaluated: 50
Correct: 43
Accuracy: 86.0%
Average Confidence: 0.91
Total Time: 145.3s
Average Time per Problem: 2.91s

Accuracy by Category:
  arithmetic: 92.3%
  percentage: 85.7%
  ratios: 80.0%
</code></pre>
<hr>
<h2 id="advanced-usage">Advanced Usage</h2>
<h3 id="custom-verification-with-critics">Custom Verification with Critics</h3>
<pre><code class="lang-csharp">using AiDotNet.Reasoning.Verification;

var chatModel = new OpenAIChatModel&lt;double&gt;(&quot;gpt-4&quot;);
var critic = new CriticModel&lt;double&gt;(chatModel);
var refinementEngine = new SelfRefinementEngine&lt;double&gt;(chatModel);

// Get reasoning step
var step = new ReasoningStep&lt;double&gt;
{
    StepNumber = 1,
    Content = &quot;Calculate 15% of 240: 240 * 1.5 = 360&quot;  // Wrong!
};

// Critique it
var context = new ReasoningContext
{
    Query = &quot;What is 15% of 240?&quot;,
    Domain = &quot;mathematics&quot;
};

var critique = await critic.CritiqueStepAsync(step, context);

Console.WriteLine($&quot;Score: {critique.Score}&quot;);
Console.WriteLine($&quot;Feedback: {critique.Feedback}&quot;);

// If failed, refine it
if (!critique.PassesThreshold)
{
    var refinedStep = await refinementEngine.RefineStepAsync(step, critique, context);
    Console.WriteLine($&quot;Refined: {refinedStep.Content}&quot;);
}
</code></pre>
<hr>
<h3 id="process-reward-models-for-rl-training">Process Reward Models for RL Training</h3>
<pre><code class="lang-csharp">using AiDotNet.Reasoning.Verification;

var chatModel = new OpenAIChatModel&lt;double&gt;(&quot;gpt-4&quot;);
var prm = new ProcessRewardModel&lt;double&gt;(chatModel);

// Score individual steps
var step = new ReasoningStep&lt;double&gt;
{
    StepNumber = 1,
    Content = &quot;Convert 15% to decimal: 15/100 = 0.15&quot;
};

var context = new ReasoningContext
{
    Query = &quot;What is 15% of 240?&quot;
};

double stepReward = await prm.CalculateStepRewardAsync(step, context);
Console.WriteLine($&quot;Step reward: {stepReward}&quot;);  // High reward for correct step

// Score complete chain
var chain = new ReasoningChain&lt;double&gt; { /* ... */ };
double chainReward = await prm.CalculateChainRewardAsync(chain, correctAnswer: &quot;36&quot;);
Console.WriteLine($&quot;Chain reward: {chainReward}&quot;);
</code></pre>
<hr>
<h3 id="diversity-sampling-and-contradiction-detection">Diversity Sampling and Contradiction Detection</h3>
<pre><code class="lang-csharp">using AiDotNet.Reasoning.Components;

// Diversity sampling
var sampler = new DiversitySampler&lt;double&gt;();
var candidates = new List&lt;ThoughtNode&lt;double&gt;&gt; { /* thoughts */ };
var diverse = sampler.SampleDiverse(candidates, numToSample: 3, config);

// Contradiction detection
var detector = new ContradictionDetector&lt;double&gt;(chatModel);
var chain = new ReasoningChain&lt;double&gt; { /* ... */ };
var contradictions = await detector.DetectContradictionsAsync(chain);

foreach (var contradiction in contradictions)
{
    Console.WriteLine($&quot;Contradiction found: {contradiction}&quot;);
}
</code></pre>
<hr>
<h2 id="configuration-presets">Configuration Presets</h2>
<h3 id="fast-mode-quick-answers">Fast Mode (Quick answers)</h3>
<pre><code class="lang-csharp">var config = ReasoningConfig.Fast();
// MaxSteps: 5, ExplorationDepth: 1, No verification
// Use for: Simple queries, rapid prototyping, high-throughput scenarios
</code></pre>
<h3 id="default-mode-balanced">Default Mode (Balanced)</h3>
<pre><code class="lang-csharp">var config = ReasoningConfig.Default();
// MaxSteps: 10, ExplorationDepth: 3, Optional verification
// Use for: Most general problems
</code></pre>
<h3 id="thorough-mode-maximum-quality">Thorough Mode (Maximum quality)</h3>
<pre><code class="lang-csharp">var config = ReasoningConfig.Thorough();
// MaxSteps: 20, ExplorationDepth: 5, Full verification + refinement
// Use for: Critical decisions, complex problems, high-stakes scenarios
</code></pre>
<hr>
<h2 id="performance-comparison">Performance Comparison</h2>
<h3 id="reasoning-strategies">Reasoning Strategies</h3>
<table>
<thead>
<tr>
<th>Strategy</th>
<th>Speed</th>
<th>Reliability</th>
<th>Best For</th>
</tr>
</thead>
<tbody>
<tr>
<td>Chain-of-Thought</td>
<td>⚡⚡⚡ Fast</td>
<td>⭐⭐⭐ Good</td>
<td>Most problems</td>
</tr>
<tr>
<td>Self-Consistency</td>
<td>⚡⚡ Medium</td>
<td>⭐⭐⭐⭐ Excellent</td>
<td>Important decisions</td>
</tr>
<tr>
<td>Tree-of-Thoughts</td>
<td>⚡ Slow</td>
<td>⭐⭐⭐⭐⭐ Best</td>
<td>Complex planning</td>
</tr>
</tbody>
</table>
<h3 id="verification-impact">Verification Impact</h3>
<table>
<thead>
<tr>
<th>Configuration</th>
<th>Accuracy</th>
<th>Speed</th>
</tr>
</thead>
<tbody>
<tr>
<td>No verification</td>
<td>~75%</td>
<td>1x</td>
</tr>
<tr>
<td>With critic</td>
<td>~85%</td>
<td>1.5x</td>
</tr>
<tr>
<td>With calculator</td>
<td>~92%</td>
<td>1.3x</td>
</tr>
<tr>
<td>With both</td>
<td>~95%</td>
<td>2x</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="research-papers-implemented">Research Papers Implemented</h2>
<p>This framework implements techniques from:</p>
<ol>
<li><strong>Chain-of-Thought Prompting</strong> (Wei et al., 2022)</li>
<li><strong>Self-Consistency with CoT</strong> (Wang et al., 2022)</li>
<li><strong>Tree of Thoughts</strong> (Yao et al., 2023)</li>
<li><strong>Let's Verify Step by Step</strong> (Lightman et al., 2023) - Process Reward Models</li>
<li><strong>Training Verifiers to Solve Math</strong> (Cobbe et al., 2021) - GSM8K</li>
<li><strong>HumanEval</strong> (Chen et al., 2021) - Code benchmarks</li>
</ol>
<p>Inspired by:</p>
<ul>
<li><strong>ChatGPT o1/o3</strong>: Test-time compute scaling</li>
<li><strong>DeepSeek-R1</strong>: RL-based verified reasoning</li>
<li><strong>AlphaGo</strong>: Monte Carlo tree search principles</li>
</ul>
<hr>
<h2 id="architecture-overview">Architecture Overview</h2>
<pre><code class="lang-text">src/Reasoning/
├── Models/                  # Core data models
│   ├── ReasoningConfig     # Configuration
│   ├── ReasoningStep       # Single reasoning step
│   ├── ReasoningChain      # Complete reasoning path
│   ├── ReasoningResult     # Final output
│   └── ThoughtNode         # Tree structure
│
├── Strategies/              # Reasoning approaches
│   ├── ChainOfThoughtStrategy
│   ├── SelfConsistencyStrategy
│   └── TreeOfThoughtsStrategy
│
├── Verification/            # Quality assurance
│   ├── CriticModel         # Evaluate steps
│   ├── SelfRefinementEngine # Improve steps
│   ├── CalculatorVerifier  # Math verification
│   └── ProcessRewardModel  # RL training
│
├── Components/              # Building blocks
│   ├── ThoughtGenerator    # Generate alternatives
│   ├── ThoughtEvaluator    # Score thoughts
│   ├── DiversitySampler    # Ensure diversity
│   └── ContradictionDetector # Find conflicts
│
├── Search/                  # Tree exploration
│   ├── BreadthFirstSearch
│   └── BeamSearch
│
├── Aggregation/             # Answer combination
│   ├── MajorityVotingAggregator
│   └── WeightedAggregator
│
├── DomainSpecific/          # Specialized reasoners
│   ├── MathematicalReasoner
│   └── CodeReasoner
│
├── Benchmarks/              # Evaluation
│   ├── GSM8KBenchmark
│   └── HumanEvalBenchmark
│
└── ComputeScaling/          # Resource allocation
    └── AdaptiveComputeScaler
</code></pre>
<hr>
<h2 id="next-steps">Next Steps</h2>
<ol>
<li><strong>Try the examples</strong> in this guide</li>
<li><strong>Run benchmarks</strong> to evaluate performance</li>
<li><strong>Experiment with configurations</strong> for your use case</li>
<li><strong>Extend with custom components</strong> (strategies, verifiers, benchmarks)</li>
</ol>
<p>For more information, see the API documentation and source code comments.</p>
<hr>
<p><strong>Framework Version:</strong> 1.0
<strong>Last Updated:</strong> 2025
<strong>License:</strong> Follow AiDotNet project license
<strong>Issues:</strong> <a href="https://github.com/ooples/AiDotNet/issues/417">Report Issues</a></p>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/ooples/AiDotNet/blob/master/docs/ReasoningFrameworkGuide.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          AiDotNet - Enterprise AI/ML Library for .NET
        </div>
      </div>
    </footer>
  </body>
</html>
