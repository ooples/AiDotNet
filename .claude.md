# AiDotNet Project - Claude Code Guidelines

## Core Architectural Rules

### 1. Always Use Custom Collections

**CRITICAL**: This project has custom collection types that MUST be used instead of primitive arrays or standard .NET collections.

#### Custom Collection Types
- **Vector&lt;T&gt;** - Use instead of `T[]` or `List<T>` for 1D data
- **Matrix&lt;T&gt;** - Use instead of `T[,]` or `List<List<T>>` for 2D data
- **Tensor&lt;T&gt;** - Use for multi-dimensional data
- **Vector&lt;int&gt;** - Use instead of `int[]` for index arrays

#### Examples

```csharp
// ❌ WRONG - Using primitive arrays
public T[] ScoreExamples(...) { ... }
public int[] SelectBatch(...) { ... }
private List<Vector<T>> centers = new List<Vector<T>>();

// ✅ CORRECT - Using custom collections
public Vector<T> ScoreExamples(...) { ... }
public Vector<int> SelectBatch(...) { ... }
private List<Vector<T>> centers = new List<Vector<T>>(); // List is OK for internal use, but expose Vector
```

### 2. Production-Ready Code Only

**NO PLACEHOLDERS OR SIMPLIFIED VERSIONS**

When implementing algorithms:
- ❌ Do NOT use hardcoded values like `int numExamples = 100`
- ❌ Do NOT use simplified/stub implementations
- ❌ Do NOT add comments like "in a real implementation..." or "simplified version"
- ✅ Always use actual dataset properties like `dataset.Count`
- ✅ Implement the full algorithm as described in academic papers
- ✅ If lacking context (e.g., labeled data for core-set), update the interface to provide it

#### Example

```csharp
// ❌ WRONG - Placeholder implementation
public Vector<T> ScoreExamples(...)
{
    int numExamples = 100; // Placeholder
    return new Vector<T>(Enumerable.Repeat(NumOps.Zero, numExamples).ToArray());
}

// ✅ CORRECT - Production implementation
public Vector<T> ScoreExamples(IFullModel<T, TInput, TOutput> model, IDataset<T, TInput, TOutput> unlabeledData)
{
    int numExamples = unlabeledData.Count;
    var scores = new T[numExamples];

    for (int i = 0; i < numExamples; i++)
    {
        var input = unlabeledData.GetInput(i);
        var prediction = model.Predict(input);
        scores[i] = ComputeScore(prediction);
    }

    return new Vector<T>(scores);
}
```

### 3. Interface Design for Real Requirements

If an algorithm fundamentally requires data that isn't in the interface, **fix the interface**:

```csharp
// ❌ WRONG - Working around interface limitations
public class CoreSetSelection
{
    private List<Vector<T>> _labeledFeatures; // Hacky workaround

    public void UpdateLabeledSet(...) // Extra method needed
}

// ✅ CORRECT - Update interface to support real needs
public interface IQueryStrategy<T, TInput, TOutput>
{
    Vector<T> ScoreExamples(
        IFullModel<T, TInput, TOutput> model,
        IDataset<T, TInput, TOutput> unlabeledData,
        IDataset<T, TInput, TOutput>? labeledData = null); // Added parameter
}
```

### 4. Framework Compatibility (.NET Framework 4.6.2+)

- ✅ Use **Newtonsoft.Json** (NOT System.Text.Json)
- ✅ Use explicit null checks with `is not null` pattern
- ❌ NEVER use null-forgiving operator `!`
- ❌ Do NOT use KeyValuePair deconstruction in net462
- ✅ Use proper default values instead of `default!`

### 5. Generic Type Parameters and Defaults

**NEVER use nullable generic types `T?` with `= null` defaults** - they cause CS1750 compilation errors.

**ALWAYS use double parameters with NumOps.FromDouble():**

```csharp
// ❌ WRONG - Nullable generic with null default
public MyClass(T? threshold = null)
{
    _threshold = threshold ?? NumOps.FromDouble(0.5);
}

// ❌ WRONG - default(T) without proper handling
public MyClass(T threshold = default(T))
{
    _threshold = threshold;
}

// ✅ CORRECT - Use double with sensible default, convert to T
public MyClass(double threshold = 0.5)
{
    _threshold = NumOps.FromDouble(threshold);
}
```

**Why this pattern?**
- Generic type T is unconstrained and cannot be nullable without `where T : struct`
- Using double provides clear, readable defaults (2.0, 1.0, 0.5)
- NumOps.FromDouble() handles conversion to any numeric type
- Avoids CS1750 compiler errors
- More intuitive for users (they pass familiar double values)

### 6. Documentation Standards

- Use `<inheritdoc/>` for interface implementations
- Add `<remarks>` with beginner-friendly explanations
- Include complexity analysis where relevant
- Reference academic papers for algorithms
- NO placeholder comments like "TODO" or "In practice..."

## Common Mistakes to Avoid

1. **Arrays instead of Vector&lt;T&gt;** - Always check return types
2. **Hardcoded sizes** - Use actual dataset/collection counts
3. **Simplified algorithms** - Implement the full production version
4. **Missing interface parameters** - Add what's needed for production use
5. **Placeholders** - Never commit placeholder code

## Review Checklist

Before committing, verify:
- [ ] No `T[]`, `int[]`, or other primitive arrays in public APIs
- [ ] All return types use Vector&lt;T&gt;, Matrix&lt;T&gt;, or Tensor&lt;T&gt;
- [ ] No hardcoded numbers (use dataset.Count, collection.Length, etc.)
- [ ] No comments mentioning "placeholder", "simplified", "in practice", "real implementation"
- [ ] All algorithms are production-ready implementations
- [ ] Interfaces provide all data needed by implementations
- [ ] Using Newtonsoft.Json, not System.Text.Json
- [ ] No null-forgiving operators `!`
