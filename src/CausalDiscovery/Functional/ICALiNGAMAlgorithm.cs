using AiDotNet.Models.Options;

namespace AiDotNet.CausalDiscovery.Functional;

/// <summary>
/// ICA-LiNGAM — Linear Non-Gaussian Acyclic Model using Independent Component Analysis.
/// </summary>
/// <remarks>
/// <para>
/// ICA-LiNGAM exploits the identifiability of the linear model X = BX + e when the noise e
/// is non-Gaussian. Using ICA (Independent Component Analysis), it recovers the mixing matrix
/// and derives the causal ordering and edge weights.
/// </para>
/// <para>
/// <b>Key insight:</b> In a linear Gaussian model, the causal direction is not identifiable
/// from observational data alone. But with non-Gaussian noise, the ICA decomposition uniquely
/// determines the causal structure — this is the LiNGAM identifiability result.
/// </para>
/// <para>
/// <b>Algorithm:</b>
/// <list type="number">
/// <item>Standardize data to zero mean, unit variance</item>
/// <item>Apply ICA (FastICA) to recover independent components S and mixing matrix A</item>
/// <item>Recover B = I - inv(A) (causal adjacency matrix)</item>
/// <item>Find a permutation that makes B lower-triangular (causal order)</item>
/// <item>Prune small coefficients</item>
/// </list>
/// </para>
/// <para>
/// <b>For Beginners:</b> If you have data generated by a linear causal model with noise
/// that isn't perfectly bell-shaped (non-Gaussian), ICA-LiNGAM can figure out the complete
/// causal structure — not just which edges exist, but which direction they go.
/// </para>
/// <para>
/// Reference: Shimizu et al. (2006), "A Linear Non-Gaussian Acyclic Model for Causal Discovery",
/// Journal of Machine Learning Research.
/// </para>
/// </remarks>
/// <typeparam name="T">The numeric type used for calculations.</typeparam>
public class ICALiNGAMAlgorithm<T> : FunctionalBase<T>
{
    /// <inheritdoc/>
    public override string Name => "ICA-LiNGAM";

    /// <inheritdoc/>
    public override bool SupportsNonlinear => false;

    private double _threshold = 0.1;

    /// <summary>
    /// Initializes ICA-LiNGAM with optional configuration.
    /// </summary>
    public ICALiNGAMAlgorithm(CausalDiscoveryOptions? options = null)
    {
        if (options?.EdgeThreshold.HasValue == true) _threshold = options.EdgeThreshold.Value;
    }

    /// <inheritdoc/>
    protected override Matrix<T> DiscoverStructureCore(Matrix<T> data)
    {
        int n = data.Rows;
        int d = data.Columns;
        var X = new double[n, d];
        for (int i = 0; i < n; i++)
            for (int j = 0; j < d; j++)
                X[i, j] = NumOps.ToDouble(data[i, j]);

        // Standardize
        X = StandardizeData(X, n, d);

        // Approximate ICA via FastICA-like deflation
        var W = FastICA(X, n, d);

        // Recover B = I - inv(W) (simplified: W ≈ inv(A), B = I - A)
        var invW = InvertMatrix(W, d);
        if (invW == null) return DoubleArrayToMatrix(new double[d, d]);

        var B = new double[d, d];
        for (int i = 0; i < d; i++)
            for (int j = 0; j < d; j++)
                B[i, j] = (i == j ? 1.0 : 0.0) - invW[i, j];

        // Find permutation to make B approximately lower triangular
        var order = FindCausalOrder(B, d);

        // Permute and threshold
        var result = new double[d, d];
        for (int i = 0; i < d; i++)
        {
            for (int j = 0; j < d; j++)
            {
                double val = B[order[i], order[j]];
                if (i != j && Math.Abs(val) >= _threshold)
                    result[order[i], order[j]] = val;
            }
        }

        // Zero diagonal
        for (int i = 0; i < d; i++) result[i, i] = 0;

        return DoubleArrayToMatrix(result);
    }

    private static double[,] FastICA(double[,] X, int n, int d)
    {
        var rng = new Random(42);
        var W = new double[d, d];

        // Initialize W as identity + small random perturbation
        for (int i = 0; i < d; i++)
        {
            W[i, i] = 1.0;
            for (int j = 0; j < d; j++)
                W[i, j] += 0.01 * (rng.NextDouble() - 0.5);
        }

        // Deflation-based FastICA
        for (int p = 0; p < d; p++)
        {
            var w = new double[d];
            for (int j = 0; j < d; j++) w[j] = rng.NextDouble() - 0.5;
            Normalize(w, d);

            for (int iter = 0; iter < 200; iter++)
            {
                var wNew = new double[d];

                // E{X * g(w^T X)} - E{g'(w^T X)} * w
                // Using g(u) = tanh(u)
                double meanGPrime = 0;
                for (int i = 0; i < n; i++)
                {
                    double u = 0;
                    for (int j = 0; j < d; j++) u += w[j] * X[i, j];

                    double g = Math.Tanh(u);
                    double gPrime = 1.0 - g * g;
                    meanGPrime += gPrime;

                    for (int j = 0; j < d; j++)
                        wNew[j] += X[i, j] * g;
                }

                meanGPrime /= n;
                for (int j = 0; j < d; j++)
                    wNew[j] = wNew[j] / n - meanGPrime * w[j];

                // Orthogonalize against previous components
                for (int k = 0; k < p; k++)
                {
                    double dot = 0;
                    for (int j = 0; j < d; j++) dot += wNew[j] * W[k, j];
                    for (int j = 0; j < d; j++) wNew[j] -= dot * W[k, j];
                }

                Normalize(wNew, d);

                // Check convergence
                double diff = 0;
                for (int j = 0; j < d; j++) diff += Math.Abs(Math.Abs(wNew[j]) - Math.Abs(w[j]));
                w = wNew;
                if (diff < 1e-6) break;
            }

            for (int j = 0; j < d; j++) W[p, j] = w[j];
        }

        return W;
    }

    private static void Normalize(double[] v, int d)
    {
        double norm = 0;
        for (int j = 0; j < d; j++) norm += v[j] * v[j];
        norm = Math.Sqrt(norm);
        if (norm > 1e-15)
            for (int j = 0; j < d; j++) v[j] /= norm;
    }

    private static int[] FindCausalOrder(double[,] B, int d)
    {
        // Find ordering that makes B most lower-triangular
        // Heuristic: order by sum of absolute values in upper triangle
        var rowSums = new double[d];
        for (int i = 0; i < d; i++)
            for (int j = i + 1; j < d; j++)
                rowSums[i] += Math.Abs(B[i, j]);

        return Enumerable.Range(0, d).OrderBy(i => rowSums[i]).ToArray();
    }

    private static double[,]? InvertMatrix(double[,] matrix, int d)
    {
        var aug = new double[d, 2 * d];
        for (int i = 0; i < d; i++)
        {
            for (int j = 0; j < d; j++) aug[i, j] = matrix[i, j];
            aug[i, i + d] = 1.0;
        }

        for (int col = 0; col < d; col++)
        {
            int maxRow = col;
            for (int row = col + 1; row < d; row++)
                if (Math.Abs(aug[row, col]) > Math.Abs(aug[maxRow, col])) maxRow = row;
            if (Math.Abs(aug[maxRow, col]) < 1e-12) return null;
            if (maxRow != col)
                for (int j = 0; j < 2 * d; j++)
                    (aug[col, j], aug[maxRow, j]) = (aug[maxRow, j], aug[col, j]);
            double pivot = aug[col, col];
            for (int j = 0; j < 2 * d; j++) aug[col, j] /= pivot;
            for (int row = 0; row < d; row++)
                if (row != col)
                {
                    double factor = aug[row, col];
                    for (int j = 0; j < 2 * d; j++) aug[row, j] -= factor * aug[col, j];
                }
        }

        var result = new double[d, d];
        for (int i = 0; i < d; i++)
            for (int j = 0; j < d; j++) result[i, j] = aug[i, j + d];
        return result;
    }
}
