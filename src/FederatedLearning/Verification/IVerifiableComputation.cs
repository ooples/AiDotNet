namespace AiDotNet.FederatedLearning.Verification;

/// <summary>
/// Defines the contract for generating and verifying proofs of computation correctness.
/// </summary>
/// <remarks>
/// <para><b>For Beginners:</b> In federated learning, the server receives gradient updates from
/// clients. But how does the server know a client actually trained correctly? A malicious client
/// could send random numbers or carefully crafted poisoning updates.</para>
///
/// <para>Verifiable computation solves this: the client generates a cryptographic "proof" alongside
/// its gradient that the server can check in milliseconds â€” even though generating the proof
/// takes much longer. If the proof verifies, the server has mathematical certainty that the
/// computation was done correctly.</para>
///
/// <para><b>Types of proofs:</b></para>
/// <list type="bullet">
/// <item><description><b>Range proofs:</b> "My gradient norm is at most C" (fast, practical).</description></item>
/// <item><description><b>Threshold proofs:</b> "My local loss is below T" (moderately expensive).</description></item>
/// <item><description><b>Computation proofs:</b> "I ran SGD for 5 epochs correctly" (expensive, research).</description></item>
/// </list>
/// </remarks>
public interface IVerifiableComputation
{
    /// <summary>
    /// Generates a proof that a value satisfies a constraint.
    /// </summary>
    /// <param name="value">The value to prove a property about (serialized).</param>
    /// <param name="constraint">The constraint to prove (e.g., "norm &lt;= 10.0").</param>
    /// <returns>A proof that can be verified by <see cref="Verify"/>.</returns>
    VerificationProof GenerateProof(byte[] value, VerificationConstraint constraint);

    /// <summary>
    /// Verifies a proof generated by <see cref="GenerateProof"/>.
    /// </summary>
    /// <param name="proof">The proof to verify.</param>
    /// <param name="constraint">The constraint that was proven.</param>
    /// <returns>True if the proof is valid, false otherwise.</returns>
    bool Verify(VerificationProof proof, VerificationConstraint constraint);

    /// <summary>
    /// Gets the name of this proof system.
    /// </summary>
    string ProofSystemName { get; }
}

/// <summary>
/// Represents a zero-knowledge proof of a computational property.
/// </summary>
public class VerificationProof
{
    /// <summary>Gets or sets the proof data.</summary>
    public byte[] ProofData { get; set; } = Array.Empty<byte>();

    /// <summary>Gets or sets the commitment to the proven value.</summary>
    public byte[] Commitment { get; set; } = Array.Empty<byte>();

    /// <summary>Gets or sets the client ID that generated this proof.</summary>
    public int ClientId { get; set; }

    /// <summary>Gets or sets the round number when the proof was generated.</summary>
    public int Round { get; set; }

    /// <summary>Gets or sets the proof system used.</summary>
    public string ProofSystem { get; set; } = string.Empty;
}

/// <summary>
/// Describes a constraint to be proven in zero-knowledge.
/// </summary>
public class VerificationConstraint
{
    /// <summary>Gets or sets the constraint type.</summary>
    public ConstraintType Type { get; set; }

    /// <summary>Gets or sets the bound value (e.g., max norm, max element value, loss threshold).</summary>
    public double Bound { get; set; }

    /// <summary>Gets or sets the dimension of the value being constrained.</summary>
    public int Dimension { get; set; }
}

/// <summary>
/// Types of constraints that can be proven in zero-knowledge.
/// </summary>
public enum ConstraintType
{
    /// <summary>Prove L2 norm is at most Bound.</summary>
    NormBound,

    /// <summary>Prove each element is in [-Bound, Bound].</summary>
    ElementBound,

    /// <summary>Prove a scalar value is at most Bound.</summary>
    ScalarBound,

    /// <summary>Prove value equals a committed value (commitment opening).</summary>
    CommitmentOpening
}
