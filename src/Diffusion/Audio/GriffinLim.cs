using AiDotNet.Helpers;
using AiDotNet.Interfaces;
using AiDotNet.Tensors.Engines;
using AiDotNet.WindowFunctions;

namespace AiDotNet.Diffusion.Audio;

/// <summary>
/// Griffin-Lim algorithm for audio reconstruction from magnitude spectrograms.
/// </summary>
/// <typeparam name="T">The numeric type used for calculations.</typeparam>
/// <remarks>
/// <para>
/// The Griffin-Lim algorithm iteratively estimates the phase of a signal given
/// only its magnitude spectrogram. This is useful when you have a spectrogram
/// (e.g., from a generative model like Riffusion) but need to reconstruct audio.
/// </para>
/// <para>
/// <b>For Beginners:</b> When we compute a spectrogram, we get both magnitude
/// (how loud each frequency is) and phase (where in its cycle each frequency is).
/// For visualization and some ML tasks, we often discard phase and keep only magnitude.
///
/// But to play back audio, we need phase information! Griffin-Lim solves this by:
/// 1. Starting with random phase
/// 2. Converting to audio (ISTFT)
/// 3. Converting back to spectrogram (STFT)
/// 4. Keeping the new phase but forcing the original magnitude
/// 5. Repeating until convergence
///
/// With momentum acceleration, convergence is typically achieved in 30-60 iterations.
///
/// Usage:
/// ```csharp
/// var griffinLim = new GriffinLim&lt;float&gt;(
///     nFft: 2048,
///     hopLength: 512,
///     iterations: 60
/// );
///
/// // From a magnitude spectrogram (e.g., generated by AI)
/// var audio = griffinLim.Reconstruct(magnitudeSpectrogram);
/// ```
/// </para>
/// </remarks>
public class GriffinLim<T>
{
    /// <summary>
    /// Provides numeric operations for the specific type T.
    /// </summary>
    private static readonly INumericOperations<T> NumOps = MathHelper.GetNumericOperations<T>();

    /// <summary>
    /// Gets the engine for GPU-accelerated operations.
    /// </summary>
    private IEngine Engine => AiDotNetEngine.Current;

    /// <summary>
    /// The STFT processor.
    /// </summary>
    private readonly ShortTimeFourierTransform<T> _stft;

    /// <summary>
    /// Window tensor for GPU operations.
    /// </summary>
    private readonly Tensor<T>? _windowTensor;

    /// <summary>
    /// FFT size for GPU operations.
    /// </summary>
    private readonly int _nFft;

    /// <summary>
    /// Hop length for GPU operations.
    /// </summary>
    private readonly int _hopLength;

    /// <summary>
    /// Number of iterations for phase estimation.
    /// </summary>
    private readonly int _iterations;

    /// <summary>
    /// Momentum factor for accelerated convergence.
    /// </summary>
    private readonly double _momentum;

    /// <summary>
    /// Random number generator for initial phase.
    /// </summary>
    private readonly Random _random;

    /// <summary>
    /// Gets the STFT processor.
    /// </summary>
    public ShortTimeFourierTransform<T> STFT => _stft;

    /// <summary>
    /// Gets the number of iterations.
    /// </summary>
    public int Iterations => _iterations;

    /// <summary>
    /// Gets the momentum factor.
    /// </summary>
    public double Momentum => _momentum;

    /// <summary>
    /// Initializes a new Griffin-Lim processor.
    /// </summary>
    /// <param name="nFft">FFT size (default: 2048).</param>
    /// <param name="hopLength">Hop length between frames (default: nFft/4).</param>
    /// <param name="windowFunction">Window function (default: Hanning - industry standard for audio STFT).</param>
    /// <param name="iterations">Number of iterations (default: 60).</param>
    /// <param name="momentum">Momentum factor for faster convergence (default: 0.99).</param>
    /// <param name="seed">Random seed for reproducibility (default: null for random).</param>
    /// <remarks>
    /// <para>
    /// <b>For Beginners:</b>
    /// - iterations: More iterations = better quality but slower. 60 is usually enough.
    /// - momentum: Higher values (0.9-0.99) converge faster. Set to 0 for original algorithm.
    ///
    /// Typical quality at different iterations:
    /// - 10 iterations: Noticeable artifacts
    /// - 30 iterations: Acceptable quality
    /// - 60 iterations: Good quality
    /// - 100+ iterations: Diminishing returns
    /// </para>
    /// </remarks>
    public GriffinLim(
        int nFft = 2048,
        int? hopLength = null,
        IWindowFunction<T>? windowFunction = null,
        int iterations = 60,
        double momentum = 0.99,
        int? seed = null)
    {
        if (nFft <= 0)
            throw new ArgumentOutOfRangeException(nameof(nFft), "FFT size must be positive.");
        if (iterations <= 0)
            throw new ArgumentOutOfRangeException(nameof(iterations), "Iterations must be positive.");
        if (momentum < 0 || momentum >= 1)
            throw new ArgumentOutOfRangeException(nameof(momentum), "Momentum must be in [0, 1).");

        _stft = new ShortTimeFourierTransform<T>(
            nFft: nFft,
            hopLength: hopLength,
            windowFunction: windowFunction);

        _iterations = iterations;
        _momentum = momentum;
        _random = seed.HasValue ? RandomHelper.CreateSeededRandom(seed.Value) : RandomHelper.CreateSecureRandom();

        // Store parameters for GPU operations
        _nFft = nFft;
        _hopLength = hopLength ?? nFft / 4;

        // Create window tensor for GPU operations
        var window = windowFunction ?? new HanningWindowFunction<T>();
        var windowData = window.CreateWindow(nFft);
        _windowTensor = new Tensor<T>(windowData, new[] { nFft });
    }

    /// <summary>
    /// Initializes Griffin-Lim with an existing STFT processor.
    /// </summary>
    /// <param name="stft">STFT processor to use.</param>
    /// <param name="iterations">Number of iterations.</param>
    /// <param name="momentum">Momentum factor.</param>
    /// <param name="seed">Random seed.</param>
    public GriffinLim(
        ShortTimeFourierTransform<T> stft,
        int iterations = 60,
        double momentum = 0.99,
        int? seed = null)
    {
        if (iterations <= 0)
            throw new ArgumentOutOfRangeException(nameof(iterations), "Iterations must be positive.");
        if (momentum < 0 || momentum >= 1)
            throw new ArgumentOutOfRangeException(nameof(momentum), "Momentum must be in [0, 1).");

        _stft = stft ?? throw new ArgumentNullException(nameof(stft));
        _iterations = iterations;
        _momentum = momentum;
        _random = seed.HasValue ? RandomHelper.CreateSeededRandom(seed.Value) : RandomHelper.CreateSecureRandom();

        // Extract parameters from STFT for GPU operations
        _nFft = stft.NFft;
        _hopLength = stft.HopLength;

        // Get window tensor from STFT if available
        _windowTensor = stft.WindowTensor;
    }

    /// <summary>
    /// Reconstructs audio from a magnitude spectrogram using Griffin-Lim.
    /// </summary>
    /// <param name="magnitude">Magnitude spectrogram [numFrames, numFreqs].</param>
    /// <param name="length">Expected output length (optional).</param>
    /// <returns>Reconstructed audio signal.</returns>
    /// <remarks>
    /// <para>
    /// <b>For Beginners:</b> This method takes a magnitude spectrogram (e.g., from a
    /// generative AI model) and creates an audio waveform that, when analyzed with
    /// STFT, produces a similar magnitude spectrogram.
    /// </para>
    /// </remarks>
    public Tensor<T> Reconstruct(Tensor<T> magnitude, int? length = null)
    {
        if (magnitude == null)
            throw new ArgumentNullException(nameof(magnitude));

        // Try GPU-accelerated Griffin-Lim first
        if (_windowTensor != null && Engine.SupportsGpu)
        {
            try
            {
                return Engine.GriffinLim(
                    magnitude,
                    _nFft,
                    _hopLength,
                    _windowTensor,
                    _iterations,
                    NumOps.FromDouble(_momentum),
                    length);
            }
            catch
            {
                // Fall back to CPU implementation
            }
        }

        // CPU fallback implementation
        int numFrames = magnitude.Shape[0];
        int numFreqs = magnitude.Shape[1];

        // Initialize with random phase
        var phase = InitializeRandomPhase(numFrames, numFreqs);
        var previousPhase = ClonePhase(phase);

        // Build initial complex spectrogram
        var complex = PolarToComplex(magnitude, phase);

        // Iterative phase estimation with momentum
        for (int iter = 0; iter < _iterations; iter++)
        {
            // Reconstruct signal from current estimate
            var signal = _stft.Inverse(complex, length);

            // Re-analyze to get new phase
            var newComplex = _stft.Forward(signal);

            // Extract new phase
            var newPhase = ExtractPhase(newComplex);

            // Apply momentum for faster convergence
            if (_momentum > 0 && iter > 0)
            {
                newPhase = ApplyMomentum(newPhase, previousPhase, phase);
            }

            // Save previous phase for momentum calculation
            CopyPhase(phase, previousPhase);
            CopyPhase(newPhase, phase);

            // Rebuild complex spectrogram with original magnitude and new phase
            complex = PolarToComplex(magnitude, phase);
        }

        // Final reconstruction
        return _stft.Inverse(complex, length);
    }

    /// <summary>
    /// Reconstructs audio from a Mel spectrogram.
    /// </summary>
    /// <param name="melSpec">Mel spectrogram from MelSpectrogram processor.</param>
    /// <param name="melProcessor">The MelSpectrogram processor used to create the Mel spectrogram.</param>
    /// <param name="length">Expected output length (optional).</param>
    /// <returns>Reconstructed audio signal.</returns>
    /// <remarks>
    /// <para>
    /// <b>For Beginners:</b> This is a convenience method that first inverts the Mel
    /// spectrogram to a linear magnitude spectrogram, then applies Griffin-Lim.
    /// </para>
    /// </remarks>
    public Tensor<T> ReconstructFromMel(
        Tensor<T> melSpec,
        MelSpectrogram<T> melProcessor,
        int? length = null)
    {
        if (melSpec == null)
            throw new ArgumentNullException(nameof(melSpec));
        if (melProcessor == null)
            throw new ArgumentNullException(nameof(melProcessor));

        // Invert Mel to magnitude spectrogram
        var magnitude = melProcessor.InvertMelToMagnitude(melSpec);

        // Apply Griffin-Lim
        return Reconstruct(magnitude, length);
    }

    /// <summary>
    /// Reconstructs audio with progress callback.
    /// </summary>
    /// <param name="magnitude">Magnitude spectrogram.</param>
    /// <param name="progressCallback">Callback called after each iteration with (iteration, convergenceMetric).</param>
    /// <param name="length">Expected output length.</param>
    /// <returns>Reconstructed audio signal.</returns>
    public Tensor<T> ReconstructWithProgress(
        Tensor<T> magnitude,
        Action<int, double> progressCallback,
        int? length = null)
    {
        if (magnitude == null)
            throw new ArgumentNullException(nameof(magnitude));

        int numFrames = magnitude.Shape[0];
        int numFreqs = magnitude.Shape[1];

        var phase = InitializeRandomPhase(numFrames, numFreqs);
        var previousPhase = ClonePhase(phase);
        var complex = PolarToComplex(magnitude, phase);

        Tensor<T>? previousSignal = null;

        for (int iter = 0; iter < _iterations; iter++)
        {
            var signal = _stft.Inverse(complex, length);
            var newComplex = _stft.Forward(signal);
            var newPhase = ExtractPhase(newComplex);

            // Calculate convergence metric (signal difference)
            double convergence = 0;
            if (previousSignal != null)
            {
                double sumSquaredDiff = 0;
                double sumSquaredSignal = 0;
                for (int i = 0; i < signal.Data.Length; i++)
                {
                    double diff = NumOps.ToDouble(signal.Data[i]) - NumOps.ToDouble(previousSignal.Data[i]);
                    sumSquaredDiff += diff * diff;
                    sumSquaredSignal += NumOps.ToDouble(signal.Data[i]) * NumOps.ToDouble(signal.Data[i]);
                }
                convergence = sumSquaredSignal > 0 ? sumSquaredDiff / sumSquaredSignal : 0;
            }

            progressCallback?.Invoke(iter, convergence);

            if (_momentum > 0 && iter > 0)
            {
                newPhase = ApplyMomentum(newPhase, previousPhase, phase);
            }

            CopyPhase(phase, previousPhase);
            CopyPhase(newPhase, phase);
            complex = PolarToComplex(magnitude, phase);
            previousSignal = signal;
        }

        return _stft.Inverse(complex, length);
    }

    /// <summary>
    /// Estimates the spectral convergence error.
    /// </summary>
    /// <param name="targetMagnitude">Target magnitude spectrogram.</param>
    /// <param name="signal">Reconstructed signal.</param>
    /// <returns>Spectral convergence error (lower is better).</returns>
    public double ComputeSpectralConvergence(Tensor<T> targetMagnitude, Tensor<T> signal)
    {
        var reconstructedMag = _stft.Magnitude(signal);

        double sumSquaredDiff = 0;
        double sumSquaredTarget = 0;

        int length = Math.Min(targetMagnitude.Data.Length, reconstructedMag.Data.Length);

        for (int i = 0; i < length; i++)
        {
            double target = NumOps.ToDouble(targetMagnitude.Data[i]);
            double recon = NumOps.ToDouble(reconstructedMag.Data[i]);
            double diff = target - recon;

            sumSquaredDiff += diff * diff;
            sumSquaredTarget += target * target;
        }

        return sumSquaredTarget > 0 ? Math.Sqrt(sumSquaredDiff / sumSquaredTarget) : 0;
    }

    /// <summary>
    /// Initializes random phase in range [-pi, pi].
    /// </summary>
    private Tensor<T> InitializeRandomPhase(int numFrames, int numFreqs)
    {
        var phase = new Tensor<T>(new[] { numFrames, numFreqs });

        for (int i = 0; i < phase.Data.Length; i++)
        {
            double randomPhase = (_random.NextDouble() * 2.0 - 1.0) * Math.PI;
            phase.Data[i] = NumOps.FromDouble(randomPhase);
        }

        return phase;
    }

    /// <summary>
    /// Clones a phase tensor.
    /// </summary>
    private static Tensor<T> ClonePhase(Tensor<T> phase)
    {
        var clone = new Tensor<T>(phase.Shape);
        Array.Copy(phase.Data, clone.Data, phase.Data.Length);
        return clone;
    }

    /// <summary>
    /// Copies phase from source to destination.
    /// </summary>
    private static void CopyPhase(Tensor<T> source, Tensor<T> dest)
    {
        Array.Copy(source.Data, dest.Data, source.Data.Length);
    }

    /// <summary>
    /// Extracts phase from complex spectrogram.
    /// </summary>
    private static Tensor<T> ExtractPhase(Tensor<Complex<T>> complex)
    {
        var phase = new Tensor<T>(complex.Shape);

        for (int i = 0; i < complex.Data.Length; i++)
        {
            phase.Data[i] = complex.Data[i].Phase;
        }

        return phase;
    }

    /// <summary>
    /// Creates complex spectrogram from magnitude and phase.
    /// </summary>
    private static Tensor<Complex<T>> PolarToComplex(Tensor<T> magnitude, Tensor<T> phase)
    {
        var complex = new Tensor<Complex<T>>(magnitude.Shape);

        for (int i = 0; i < magnitude.Data.Length; i++)
        {
            complex.Data[i] = Complex<T>.FromPolarCoordinates(magnitude.Data[i], phase.Data[i]);
        }

        return complex;
    }

    /// <summary>
    /// Applies momentum to phase update for faster convergence.
    /// </summary>
    /// <remarks>
    /// <para>
    /// <b>For Beginners:</b> Momentum helps the algorithm converge faster by using
    /// information from previous iterations. It's like a ball rolling downhill that
    /// picks up speed and overshoots less.
    ///
    /// The formula is: new_phase = current_phase + momentum * (current_phase - previous_phase)
    /// </para>
    /// </remarks>
    private Tensor<T> ApplyMomentum(Tensor<T> newPhase, Tensor<T> previousPhase, Tensor<T> currentPhase)
    {
        var result = new Tensor<T>(newPhase.Shape);
        T momentumT = NumOps.FromDouble(_momentum);

        for (int i = 0; i < newPhase.Data.Length; i++)
        {
            // Compute phase velocity (difference between current and previous)
            var velocity = NumOps.Subtract(currentPhase.Data[i], previousPhase.Data[i]);

            // Apply momentum: new_phase + momentum * velocity
            var momentumContrib = NumOps.Multiply(momentumT, velocity);
            result.Data[i] = NumOps.Add(newPhase.Data[i], momentumContrib);

            // Wrap to [-pi, pi]
            double phaseVal = NumOps.ToDouble(result.Data[i]);
            while (phaseVal > Math.PI) phaseVal -= 2 * Math.PI;
            while (phaseVal < -Math.PI) phaseVal += 2 * Math.PI;
            result.Data[i] = NumOps.FromDouble(phaseVal);
        }

        return result;
    }
}
