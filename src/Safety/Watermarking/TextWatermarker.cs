using AiDotNet.Enums;
using AiDotNet.Interfaces;
using AiDotNet.Models;
using AiDotNet.Safety;
using AiDotNet.Tensors.LinearAlgebra;

namespace AiDotNet.Safety.Watermarking;

/// <summary>
/// Embeds and detects invisible watermarks in AI-generated text using token distribution biasing.
/// </summary>
/// <remarks>
/// <para>
/// Uses the "green list" approach inspired by SynthID-Text (Google DeepMind, Nature 2024).
/// During generation, tokens are partitioned into a "green" and "red" set using a keyed hash
/// of the preceding context. The model is biased toward green tokens. Detection counts the
/// proportion of green tokens to estimate whether the text was watermarked.
/// </para>
/// <para>
/// <b>For Beginners:</b> Text watermarking works by subtly biasing which words the AI chooses.
/// When generating text, the system slightly prefers certain words over others in a way that
/// is invisible to humans but detectable by the system. Later, the system can check if a
/// piece of text was generated by this AI by counting how many "preferred" words appear.
/// </para>
/// <para>
/// <b>Algorithm:</b>
/// 1. For each token position, hash the preceding N tokens with a secret key
/// 2. Use the hash to partition the vocabulary into green/red sets
/// 3. During generation: bias logits toward green tokens by adding a delta
/// 4. During detection: count green token fraction and apply statistical test
/// </para>
/// <para>
/// <b>References:</b>
/// - SynthID-Text: Scalable, high-quality watermarking at production scale (Google DeepMind, Nature 2024)
/// - Adaptive text watermarking resistant to paraphrasing (ICLR 2024)
/// - KGW: Watermarking for large language models (Kirchenbauer et al., 2023)
/// - Unbiased watermark estimation for LLMs (2024)
/// </para>
/// </remarks>
/// <typeparam name="T">The numeric type used for calculations.</typeparam>
public class TextWatermarker<T> : ITextSafetyModule<T>
{
    private readonly byte[] _secretKey;
    private readonly double _greenListFraction;
    private readonly double _detectionThreshold;
    private readonly int _contextWidth;

    /// <inheritdoc />
    public string ModuleName => "TextWatermarker";

    /// <inheritdoc />
    public bool IsReady => true;

    /// <summary>
    /// Initializes a new text watermarker.
    /// </summary>
    /// <param name="secretKey">
    /// Secret key used for green/red list partitioning. If null, a default key is used.
    /// In production, use a unique, securely generated key per deployment.
    /// </param>
    /// <param name="greenListFraction">
    /// Fraction of vocabulary in the green list (0-1). Default: 0.5.
    /// Higher values make detection easier but may slightly affect text quality.
    /// </param>
    /// <param name="detectionThreshold">
    /// Z-score threshold for watermark detection. Default: 4.0 (corresponds to p &lt; 0.00003).
    /// Based on SynthID-Text's recommended detection threshold.
    /// </param>
    /// <param name="contextWidth">
    /// Number of preceding tokens used for hash context. Default: 1.
    /// </param>
    public TextWatermarker(
        byte[]? secretKey = null,
        double greenListFraction = 0.5,
        double detectionThreshold = 4.0,
        int contextWidth = 1)
    {
        if (secretKey is null || secretKey.Length == 0)
        {
            // Generate a cryptographically random key when none is provided.
            // Callers should persist and reuse a key for consistent watermark detection.
            _secretKey = new byte[32];
            using var rng = System.Security.Cryptography.RandomNumberGenerator.Create();
            rng.GetBytes(_secretKey);
        }
        else
        {
            _secretKey = (byte[])secretKey.Clone();
        }

        _greenListFraction = Math.Max(0.1, Math.Min(0.9, greenListFraction));
        _detectionThreshold = detectionThreshold;
        _contextWidth = Math.Max(1, contextWidth);
    }

    /// <summary>
    /// Detects whether the given text contains a watermark from this system.
    /// </summary>
    /// <param name="text">The text to check for watermarks.</param>
    /// <returns>
    /// A list of findings. If a watermark is detected, a finding with
    /// <see cref="SafetyCategory.Watermarked"/> is returned.
    /// </returns>
    public IReadOnlyList<SafetyFinding> EvaluateText(string text)
    {
        var findings = new List<SafetyFinding>();

        if (string.IsNullOrWhiteSpace(text))
        {
            return findings;
        }

        // Tokenize into words (simple whitespace tokenization)
        var tokens = TokenizeSimple(text);

        if (tokens.Length < _contextWidth + 5)
        {
            return findings; // Too short to reliably detect
        }

        // Count green tokens
        int greenCount = 0;
        int totalTokens = 0;

        for (int i = _contextWidth; i < tokens.Length; i++)
        {
            int contextHash = ComputeContextHash(tokens, i);
            bool isGreen = IsGreenToken(tokens[i], contextHash);

            if (isGreen)
            {
                greenCount++;
            }

            totalTokens++;
        }

        if (totalTokens == 0)
        {
            return findings;
        }

        // Compute z-score for green fraction
        double observedGreenFraction = (double)greenCount / totalTokens;
        double expectedGreenFraction = _greenListFraction;
        double variance = expectedGreenFraction * (1 - expectedGreenFraction) / totalTokens;
        double zScore = variance > 0
            ? (observedGreenFraction - expectedGreenFraction) / Math.Sqrt(variance)
            : 0;

        if (zScore >= _detectionThreshold)
        {
            double confidence = Math.Min(1.0, zScore / (_detectionThreshold * 2));

            findings.Add(new SafetyFinding
            {
                Category = SafetyCategory.Watermarked,
                Severity = SafetySeverity.Info,
                Confidence = confidence,
                Description = $"Text contains a statistical watermark signature (z-score: {zScore:F2}, " +
                              $"green fraction: {observedGreenFraction:F3} vs expected {expectedGreenFraction:F3}).",
                RecommendedAction = SafetyAction.Log,
                SourceModule = ModuleName
            });
        }

        return findings;
    }

    /// <inheritdoc />
    public IReadOnlyList<SafetyFinding> Evaluate(Vector<T> content)
    {
        if (content is null)
        {
            throw new ArgumentNullException(nameof(content));
        }

        // Convert vector to string (character codes) and delegate to text evaluation.
        var numOps = MathHelper.GetNumericOperations<T>();
        var chars = new char[content.Length];
        for (int i = 0; i < content.Length; i++)
        {
            int code = (int)Math.Round(numOps.ToDouble(content[i]));
            chars[i] = code is >= 0 and <= 65535 ? (char)code : '?';
        }

        return EvaluateText(new string(chars));
    }

    private static string[] TokenizeSimple(string text)
    {
        return text.Split(new[] { ' ', '\t', '\n', '\r' }, StringSplitOptions.RemoveEmptyEntries);
    }

    private int ComputeContextHash(string[] tokens, int position)
    {
        int hash = 17;
        int start = Math.Max(0, position - _contextWidth);

        for (int i = start; i < position; i++)
        {
            hash = hash * 31 + DeterministicStringHash(tokens[i]);
        }

        // Mix in secret key
        for (int i = 0; i < _secretKey.Length; i++)
        {
            hash = hash * 31 + _secretKey[i];
        }

        return hash;
    }

    private bool IsGreenToken(string token, int contextHash)
    {
        // Deterministically classify token as green/red based on context hash
        int tokenHash = DeterministicStringHash(token);
        int combined = contextHash ^ tokenHash;

        // Use modular arithmetic to get a fraction in [0,1)
        double fraction = ((combined & 0x7FFFFFFF) % 10000) / 10000.0;
        return fraction < _greenListFraction;
    }

    /// <summary>
    /// Deterministic hash for strings that is consistent across processes and .NET versions.
    /// string.GetHashCode() is randomized per process in .NET Core, making it unsuitable
    /// for watermark detection across different processes.
    /// </summary>
    private static int DeterministicStringHash(string s)
    {
        unchecked
        {
            int hash = 5381;
            for (int i = 0; i < s.Length; i++)
            {
                hash = ((hash << 5) + hash) ^ s[i];
            }
            return hash;
        }
    }
}
