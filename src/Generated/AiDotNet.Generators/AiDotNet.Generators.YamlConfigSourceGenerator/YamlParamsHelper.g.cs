// <auto-generated/>
#nullable enable

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Globalization;
using System.Reflection;

namespace AiDotNet.Configuration;

/// <summary>
/// Applies a dictionary of YAML parameters to an object's properties via reflection.
/// </summary>
/// <remarks>
/// <para><b>For Beginners:</b> This helper takes the <c>params:</c> section from YAML
/// and sets the matching properties on the target object. Property names are matched
/// case-insensitively, and values are converted to the correct types automatically.</para>
/// </remarks>
internal static class YamlParamsHelper
{
    /// <summary>
    /// Sets properties on <paramref name="target"/> from the key/value pairs in <paramref name="parameters"/>.
    /// </summary>
    /// <param name="target">The object whose properties will be set.</param>
    /// <param name="parameters">Dictionary of property names to values.</param>
    internal static void ApplyParams(object target, Dictionary<string, object>? parameters)
    {
        if (target is null || parameters is null || parameters.Count == 0) return;

        var targetType = target.GetType();

        foreach (var kvp in parameters)
        {
            var prop = targetType.GetProperty(kvp.Key,
                BindingFlags.Public | BindingFlags.Instance | BindingFlags.IgnoreCase);

            if (prop is null || !prop.CanWrite) continue;

            try
            {
                var value = ConvertValue(kvp.Value, prop.PropertyType);
                prop.SetValue(target, value);
            }
            catch (Exception)
            {
                // Skip properties that can't be converted — user may have a typo.
                // In debug builds this could log a warning.
            }
        }
    }

    private static object? ConvertValue(object? value, Type targetType)
    {
        if (value is null) return null;

        // Unwrap Nullable<T>
        var underlyingType = Nullable.GetUnderlyingType(targetType) ?? targetType;

        // Handle enums from string
        if (underlyingType.IsEnum && value is string enumString)
        {
            return Enum.Parse(underlyingType, enumString, ignoreCase: true);
        }

        // Handle TypeConverter for complex types
        var converter = TypeDescriptor.GetConverter(underlyingType);
        if (converter.CanConvertFrom(value.GetType()))
        {
            return converter.ConvertFrom(null, CultureInfo.InvariantCulture, value);
        }

        // Fallback to Convert.ChangeType
        return Convert.ChangeType(value, underlyingType, CultureInfo.InvariantCulture);
    }
}
