using System.Security.Cryptography;
using System.Text;
using AiDotNet.LinearAlgebra;

namespace AiDotNet.Caching;

/// <summary>
/// Provides deterministic cache key generation using SHA-256 hashing.
/// </summary>
/// <remarks>
/// <para>
/// This class generates cache keys that are:
/// - Deterministic: Same input always produces the same key
/// - Process-independent: Keys are consistent across process restarts
/// - Collision-resistant: Uses SHA-256 cryptographic hash
/// </para>
/// <para>
/// <b>For Beginners:</b> This is like creating a unique fingerprint for data that stays
/// the same no matter when or where you create it. Unlike GetHashCode(), which can produce
/// different values in different program runs, this always produces the same result for
/// the same data.
/// </para>
/// </remarks>
internal static class DeterministicCacheKeyGenerator
{
    /// <summary>
    /// Generates a deterministic cache key from model parameters and input data shapes.
    /// </summary>
    /// <typeparam name="T">The numeric type used for calculations.</typeparam>
    /// <param name="parameters">The model parameter vector.</param>
    /// <param name="inputDataDescriptor">A stable string describing the input data structure.</param>
    /// <returns>A deterministic hex-encoded SHA-256 hash string.</returns>
    /// <remarks>
    /// <para>
    /// The key is generated by:
    /// 1. Serializing parameters and input descriptor to a stable string format
    /// 2. Computing SHA-256 hash of the UTF-8 bytes
    /// 3. Converting the hash to a lowercase hex string
    /// </para>
    /// <para>
    /// This ensures cache keys remain valid across process restarts and different machines.
    /// </para>
    /// </remarks>
    public static string GenerateKey<T>(Vector<T> parameters, string inputDataDescriptor)
    {
        if (parameters == null) throw new ArgumentNullException(nameof(parameters));
        if (inputDataDescriptor == null) throw new ArgumentNullException(nameof(inputDataDescriptor));

        // Build stable string representation
        var sb = new StringBuilder();

        // Add parameter count and values (stable ordering)
        sb.Append("params:");
        sb.Append(parameters.Length);
        sb.Append("|");

        // Add each parameter value in order
        for (int i = 0; i < parameters.Length; i++)
        {
            if (i > 0) sb.Append(",");
            // Use invariant culture to ensure consistent number formatting
            sb.Append(Convert.ToDouble(parameters[i]).ToString("R", System.Globalization.CultureInfo.InvariantCulture));
        }

        // Add input data descriptor
        sb.Append("|input:");
        sb.Append(inputDataDescriptor.Trim());

        // Compute SHA-256 hash
        byte[] inputBytes = Encoding.UTF8.GetBytes(sb.ToString());
        byte[] hashBytes;

        using (var sha256 = SHA256.Create())
        {
            hashBytes = sha256.ComputeHash(inputBytes);
        }

        // Convert to hex string (lowercase for consistency)
        return BitConverter.ToString(hashBytes).Replace("-", "").ToLowerInvariant();
    }

    /// <summary>
    /// Creates a stable descriptor string for input data based on type and shape information.
    /// </summary>
    /// <typeparam name="T">The numeric type.</typeparam>
    /// <typeparam name="TInput">The input data type.</typeparam>
    /// <typeparam name="TOutput">The output data type.</typeparam>
    /// <param name="xTrain">Training input data.</param>
    /// <param name="yTrain">Training output data.</param>
    /// <param name="xValidation">Validation input data (optional).</param>
    /// <param name="yValidation">Validation output data (optional).</param>
    /// <param name="xTest">Test input data (optional).</param>
    /// <param name="yTest">Test output data (optional).</param>
    /// <returns>A stable string descriptor of the data structure.</returns>
    /// <remarks>
    /// <para>
    /// This method creates a descriptor that captures the structure of the data without
    /// including the actual data values. This is faster and more efficient for cache key
    /// generation while still being deterministic.
    /// </para>
    /// <para>
    /// The descriptor includes:
    /// - Data type names
    /// - Shapes/dimensions of matrices, vectors, and tensors
    /// - Dataset split information (train/validation/test)
    /// </para>
    /// </remarks>
    public static string CreateInputDataDescriptor<T, TInput, TOutput>(
        TInput xTrain, TOutput yTrain,
        TInput? xValidation = default, TOutput? yValidation = default,
        TInput? xTest = default, TOutput? yTest = default)
    {
        var sb = new StringBuilder();

        // Add training data shape
        sb.Append("train:");
        sb.Append(GetShapeDescriptor(xTrain));
        sb.Append("x");
        sb.Append(GetShapeDescriptor(yTrain));

        // Add validation data shape if present
        if (xValidation != null && yValidation != null)
        {
            sb.Append("|val:");
            sb.Append(GetShapeDescriptor(xValidation));
            sb.Append("x");
            sb.Append(GetShapeDescriptor(yValidation));
        }

        // Add test data shape if present
        if (xTest != null && yTest != null)
        {
            sb.Append("|test:");
            sb.Append(GetShapeDescriptor(xTest));
            sb.Append("x");
            sb.Append(GetShapeDescriptor(yTest));
        }

        return sb.ToString();
    }

    /// <summary>
    /// Gets a stable shape descriptor for various data types.
    /// </summary>
    /// <typeparam name="TData">The data type.</typeparam>
    /// <param name="data">The data object.</param>
    /// <returns>A string describing the shape/structure of the data.</returns>
    private static string GetShapeDescriptor<TData>(TData data)
    {
        if (data == null) return "null";

        var type = data.GetType();

        // Handle Matrix<T> - check if it's the generic Matrix type
        if (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(Matrix<>))
        {
            // Use reflection to get Rows and Columns properties
            var rowsProp = type.GetProperty("Rows");
            var colsProp = type.GetProperty("Columns");
            if (rowsProp != null && colsProp != null)
            {
                int rows = (int)(rowsProp.GetValue(data) ?? 0);
                int cols = (int)(colsProp.GetValue(data) ?? 0);
                return $"Matrix({rows},{cols})";
            }
        }

        // Handle Vector<T> - check if it's the generic Vector type
        if (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(Vector<>))
        {
            // Use reflection to get Length property
            var lengthProp = type.GetProperty("Length");
            if (lengthProp != null)
            {
                int length = (int)(lengthProp.GetValue(data) ?? 0);
                return $"Vector({length})";
            }
        }

        // Handle Tensor<T>
        if (type.IsGenericType && type.GetGenericTypeDefinition().Name.StartsWith("Tensor"))
        {
            // Use reflection to get Shape property
            var shapeProperty = type.GetProperty("Shape");
            if (shapeProperty != null)
            {
                var shape = shapeProperty.GetValue(data) as int[];
                if (shape != null)
                {
                    return $"Tensor({string.Join(",", shape)})";
                }
            }
        }

        // Fallback to type name
        return type.Name;
    }
}
