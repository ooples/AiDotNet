using AiDotNet.Helpers;
using AiDotNet.Interfaces;

namespace AiDotNet.Evaluation.CrossValidation;

/// <summary>
/// Nested Cross-Validation: uses an inner CV loop for hyperparameter tuning and outer loop for evaluation.
/// </summary>
/// <remarks>
/// <para><b>For Beginners:</b> Nested CV is essential when you need to both tune hyperparameters
/// AND get an unbiased estimate of model performance:
/// <list type="bullet">
/// <item>Outer loop: Evaluates final model performance (e.g., 5-fold)</item>
/// <item>Inner loop: Selects best hyperparameters (e.g., 3-fold within each outer fold)</item>
/// </list>
/// </para>
/// <para>
/// <b>Why is this necessary?</b> If you tune hyperparameters on the same data you evaluate on,
/// you get optimistically biased estimates. Nested CV keeps evaluation data completely separate
/// from hyperparameter selection.
/// </para>
/// <para>
/// <b>Structure:</b>
/// <code>
/// For each outer fold:
///   Train data = outer training folds
///   Test data = outer test fold
///   For each inner fold (on train data only):
///     Tune hyperparameters using inner train/val split
///   Train final model on full outer train data with best hyperparameters
///   Evaluate on outer test fold
/// </code>
/// </para>
/// </remarks>
public class NestedCVStrategy<T> : ICrossValidationStrategy<T>
{
    private static readonly INumericOperations<T> NumOps = MathHelper.GetNumericOperations<T>();
    private readonly int _outerFolds;
    private readonly int _innerFolds;
    private readonly bool _shuffle;
    private readonly int? _randomSeed;

    /// <summary>
    /// Initializes Nested Cross-Validation.
    /// </summary>
    /// <param name="outerFolds">Number of outer folds for performance evaluation. Default is 5.</param>
    /// <param name="innerFolds">Number of inner folds for hyperparameter tuning. Default is 3.</param>
    /// <param name="shuffle">Whether to shuffle data. Default is true.</param>
    /// <param name="randomSeed">Random seed for reproducibility.</param>
    public NestedCVStrategy(int outerFolds = 5, int innerFolds = 3, bool shuffle = true, int? randomSeed = null)
    {
        if (outerFolds < 2) throw new ArgumentException("Outer folds must be at least 2.", nameof(outerFolds));
        if (innerFolds < 2) throw new ArgumentException("Inner folds must be at least 2.", nameof(innerFolds));

        _outerFolds = outerFolds;
        _innerFolds = innerFolds;
        _shuffle = shuffle;
        _randomSeed = randomSeed;
    }

    public string Name => $"Nested CV ({_outerFolds}Ã—{_innerFolds})";
    public int NumSplits => _outerFolds;
    public string Description => $"Nested CV with {_outerFolds} outer folds and {_innerFolds} inner folds for hyperparameter tuning.";

    public IEnumerable<(int[] TrainIndices, int[] ValidationIndices)> Split(int dataSize, ReadOnlySpan<T> labels = default)
    {
        // The outer loop is returned as splits
        // Inner loop splits would be generated by the caller on the training data
        var outerCV = new KFoldStrategy<T>(_outerFolds, _shuffle, _randomSeed);
        return outerCV.Split(dataSize, labels);
    }

    /// <summary>
    /// Gets inner CV splits for hyperparameter tuning within a specific outer fold's training data.
    /// </summary>
    /// <param name="outerTrainIndices">Training indices from the outer fold.</param>
    /// <param name="labels">Optional labels for stratified inner splits.</param>
    /// <returns>Inner fold splits operating on the outer training indices.</returns>
    public IEnumerable<(int[] InnerTrainIndices, int[] InnerValidationIndices)> GetInnerSplits(
        int[] outerTrainIndices, ReadOnlySpan<T> labels = default)
    {
        int innerDataSize = outerTrainIndices.Length;
        var innerCV = new KFoldStrategy<T>(_innerFolds, _shuffle, _randomSeed.HasValue ? _randomSeed.Value + 1 : null);

        foreach (var (innerTrainRelative, innerValRelative) in innerCV.Split(innerDataSize))
        {
            // Map relative indices back to original data indices
            var innerTrain = new int[innerTrainRelative.Length];
            var innerVal = new int[innerValRelative.Length];

            for (int i = 0; i < innerTrainRelative.Length; i++)
                innerTrain[i] = outerTrainIndices[innerTrainRelative[i]];

            for (int i = 0; i < innerValRelative.Length; i++)
                innerVal[i] = outerTrainIndices[innerValRelative[i]];

            yield return (innerTrain, innerVal);
        }
    }
}
