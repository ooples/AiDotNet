name: Fix Commit Messages

on:
  pull_request:
    types: [opened, synchronize, reopened]

permissions:
  contents: write
  pull-requests: write

jobs:
  check-and-fix-commits:
    name: Check and Fix Non-Compliant Commits
    runs-on: ubuntu-latest
    # Skip for dependabot PRs (they have special handling)
    if: |
      github.actor != 'dependabot[bot]' &&
      github.event.pull_request.head.repo.full_name == github.repository
    env:
      AUTOFIX_GPG_PRIVATE_KEY: ${{ secrets.AUTOFIX_GPG_PRIVATE_KEY }}
      AUTOFIX_GPG_PASSPHRASE: ${{ secrets.AUTOFIX_GPG_PASSPHRASE }}
      AUTOFIX_BOT_NAME: AiDotNetAutofixBot
      AUTOFIX_BOT_EMAIL: autofix-bot@ooples.com

    steps:
      - name: Checkout code
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6
        with:
          ref: ${{ github.head_ref }}
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
          persist-credentials: false

      - name: Import GPG key for signed commits
        if: env.AUTOFIX_GPG_PRIVATE_KEY != ''
        uses: crazy-max/ghaction-import-gpg@e89d40939c28e39f97cf32126055eeae86ba74ec # v6
        with:
          gpg_private_key: ${{ env.AUTOFIX_GPG_PRIVATE_KEY }}
          passphrase: ${{ env.AUTOFIX_GPG_PASSPHRASE }}
          git_user_signingkey: true
          git_commit_gpgsign: true

      - name: Configure Git
        env:
          AUTOFIX_PAT: ${{ secrets.AUTOFIX_PAT }}
        run: |
          if [ -n "$AUTOFIX_PAT" ]; then
            git config user.name "$AUTOFIX_BOT_NAME"
            git config user.email "$AUTOFIX_BOT_EMAIL"
          else
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
          fi

      - name: Get commits to check
        id: get-commits
        run: |
          BASE_BRANCH="${{ github.base_ref }}"
          git fetch origin "$BASE_BRANCH"

          # Get all commits in PR
          COMMITS=$(git rev-list --reverse "origin/$BASE_BRANCH..HEAD")
          COMMITS_COUNT=$(echo "$COMMITS" | grep -c . || echo 0)

          echo "commits<<EOF" >> $GITHUB_OUTPUT
          echo "$COMMITS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "commit_count=$COMMITS_COUNT" >> $GITHUB_OUTPUT

          echo "Found $COMMITS_COUNT commits to check"

      - name: Check each commit for compliance
        id: check-commits
        run: |
          COMMITS="${{ steps.get-commits.outputs.commits }}"
          NEEDS_FIX=false
          FIXED_COMMITS=()
          # Bash [[ =~ ]] regex must be a single token: avoid literal spaces (use [[:space:]]).
          PATTERN='^(feat|fix|docs|refactor|perf|test|chore|ci|style|deps)(\([^)]+\))?:[[:space:]].+'

          while IFS= read -r commit_sha; do
            if [ -z "$commit_sha" ]; then continue; fi

            COMMIT_MSG=$(git log -1 --format=%B "$commit_sha")
            FIRST_LINE=$(echo "$COMMIT_MSG" | head -1)

            # Only skip git-generated merge commits that commitlint.config.js ignores
            # These are auto-generated by git and cannot follow conventional commits format
            if [[ "$FIRST_LINE" =~ ^Merge\ pull\ request\ \#[0-9]+ ]]; then
              echo "Skipping GitHub PR merge commit: $commit_sha"
              continue
            fi
            if [[ "$FIRST_LINE" =~ ^Merge\ branch\ \'.+\' ]]; then
              echo "Skipping git branch merge commit: $commit_sha"
              continue
            fi
            if [[ "$FIRST_LINE" =~ ^Merge\ remote-tracking\ branch ]]; then
              echo "Skipping remote tracking merge commit: $commit_sha"
              continue
            fi
            if [[ "$FIRST_LINE" =~ ^Merge\ (origin|upstream|master|main) ]]; then
              echo "Skipping standard merge commit: $commit_sha"
              continue
            fi

            # Check if commit follows conventional commits
            # Valid types: feat, fix, docs, refactor, perf, test, chore, ci, style, deps
            if [[ "$FIRST_LINE" =~ $PATTERN ]]; then
              # Extract description after colon
              DESCRIPTION=$(echo "$FIRST_LINE" | cut -d':' -f2- | sed 's/^ *//')

              # Check if description starts with lowercase
              if [[ "$DESCRIPTION" =~ ^[a-z] ]]; then
                echo "‚úÖ Valid commit: $FIRST_LINE"
              else
                echo "‚ùå Invalid subject case: $FIRST_LINE"
                INVALID_SUBJECT=true
                NEEDS_FIX=true

                # Fix the subject case
                TYPE=$(echo "$FIRST_LINE" | cut -d':' -f1)
                FIXED_DESCRIPTION=$(echo "$DESCRIPTION" | sed 's/./\L&/')
                NEW_SUBJECT="$TYPE: $FIXED_DESCRIPTION"

                # Get the body (everything after first line and blank line)
                BODY=$(echo "$COMMIT_MSG" | tail -n +3 | awk '{$1=$1};1')

                if [ -n "$BODY" ]; then
                  NEW_MSG="$NEW_SUBJECT\n\n$BODY"
                else
                  NEW_MSG="$NEW_SUBJECT"
                fi

                echo "Will fix to: $NEW_SUBJECT"
                FIXED_COMMITS+=("$commit_sha:$NEW_MSG")
              fi
            else
              echo "‚ùå Invalid format: $FIRST_LINE"
              NEEDS_FIX=true

              # Try to fix based on common patterns
              TYPE="chore"  # Default type
              DESCRIPTION="$FIRST_LINE"

              # Detect type from message
              if [[ "$FIRST_LINE" =~ ^[Aa]dd.*|[Ii]mplement.*|[Cc]reate.*|[Ii]ntroduce.* ]]; then
                TYPE="feat"
              elif [[ "$FIRST_LINE" =~ ^[Ff]ix.*|[Cc]orrect.*|[Rr]esolve.*|[Pp]atch.* ]]; then
                TYPE="fix"
              elif [[ "$FIRST_LINE" =~ ^[Dd]ocument.*|[Uu]pdate\ documentation.* ]]; then
                TYPE="docs"
              elif [[ "$FIRST_LINE" =~ ^[Rr]efactor.* ]]; then
                TYPE="refactor"
              elif [[ "$FIRST_LINE" =~ ^[Tt]est.* ]]; then
                TYPE="test"
              elif [[ "$FIRST_LINE" =~ ^[Bb]ump.*|[Uu]pdate.*version.*|[Dd]ependency.* ]]; then
                TYPE="deps"
              fi

              FIXED_DESCRIPTION=$(echo "$DESCRIPTION" | sed 's/^[A-Z]/\L&/')
              NEW_SUBJECT="$TYPE: $FIXED_DESCRIPTION"

              # Get the body
              BODY=$(echo "$COMMIT_MSG" | tail -n +3 | awk '{$1=$1};1')

              if [ -n "$BODY" ]; then
                NEW_MSG="$NEW_SUBJECT\n\n$BODY\n\nCommit message auto-fixed by GitHub Actions to follow conventional commits format.\n\nCo-Authored-By: github-actions[bot] <github-actions[bot]@users.noreply.github.com>"
              else
                NEW_MSG="$NEW_SUBJECT\n\nCommit message auto-fixed by GitHub Actions to follow conventional commits format.\n\nCo-Authored-By: github-actions[bot] <github-actions[bot]@users.noreply.github.com>"
              fi

              echo "Will fix to: $NEW_SUBJECT"
              FIXED_COMMITS+=("$commit_sha:$NEW_MSG")
            fi
          done <<< "$COMMITS"

          if [ "$NEEDS_FIX" = true ]; then
            echo "needs_fix=true" >> $GITHUB_OUTPUT
            echo "Fixed ${#FIXED_COMMITS[@]} commits"
          else
            echo "needs_fix=false" >> $GITHUB_OUTPUT
          fi

      - name: Apply fixes to commits
        if: steps.check-commits.outputs.needs_fix == 'true'
        run: |
          if [ -z "$AUTOFIX_GPG_PRIVATE_KEY" ]; then
            echo "::error::Repository rules require signed commits. Configure secrets AUTOFIX_GPG_PRIVATE_KEY and AUTOFIX_GPG_PASSPHRASE so this workflow can create signed rewritten commits."
            exit 1
          fi

          COMMITS="${{ steps.get-commits.outputs.commits }}"
          BASE_BRANCH="${{ github.base_ref }}"

          # Reset to base branch keeping changes staged
          git reset --soft "origin/$BASE_BRANCH"

          # Create individual commits for each fix
          # Note: This is a simplified approach - in practice, we might want to preserve the original commit structure
          echo "All changes have been staged. Creating a single commit with fixes..."

          cat <<'EOF' | sed 's/^__MSG__//' | git commit -F-
          __MSG__chore: fix commit messages for conventional compliance
          __MSG__
          __MSG__This commit fixes one or more commit messages that didn't follow
          __MSG__conventional commits format. The original commits have been
          __MSG__squashed and their messages updated to comply with the project's
          __MSG__standards.
          __MSG__
          __MSG__Original issues fixed:
          __MSG__- Subject line now follows lowercase convention
          __MSG__- Type now uses valid conventional commit types
          __MSG__
          __MSG__Co-Authored-By: github-actions[bot] <github-actions[bot]@users.noreply.github.com>
          EOF

      - name: Force push fixes
        if: steps.check-commits.outputs.needs_fix == 'true'
        env:
          HEAD_REF: ${{ github.head_ref }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          AUTOFIX_PAT: ${{ secrets.AUTOFIX_PAT }}
        run: |
          BRANCH="$HEAD_REF"
          git checkout -B "$BRANCH"
          push_with_token () {
            local token="$1"
            git remote set-url origin "https://x-access-token:${token}@github.com/${GITHUB_REPOSITORY}.git"
            git push origin "$BRANCH" --force-with-lease
          }

          if [ -n "$AUTOFIX_PAT" ]; then
            echo "Attempting push using AUTOFIX_PAT..."
            if push_with_token "$AUTOFIX_PAT"; then
              exit 0
            fi
            echo "::warning::Push using AUTOFIX_PAT failed. Falling back to GITHUB_TOKEN."
          else
            echo "::warning::AUTOFIX_PAT is not set. Downstream PR checks may not rerun automatically after this workflow force-pushes."
          fi

          echo "Attempting push using GITHUB_TOKEN..."
          push_with_token "$GITHUB_TOKEN"

      - name: Comment on PR
        if: steps.check-commits.outputs.needs_fix == 'true'
        uses: actions/github-script@f28e40c7f34bde8b3046d885e986cb6290c5673b # v7
        with:
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: [
                '### ü§ñ Commit Messages Auto-Fixed',
                '',
                "The commitlint check failed because one or more commit messages didn't follow [Conventional Commits](https://www.conventionalcommits.org/) format.",
                '',
                '**Action taken** ‚Äî All non-compliant commits have been fixed to follow the conventional commits format.',
                '',
                '**Changes made:**',
                "- Subject lines are now lowercase (except 'deps' type)",
                '- Types are now one of: `feat`, `fix`, `docs`, `refactor`, `perf`, `test`, `chore`, `ci`, `style`, or `deps`',
                '',
                'The PR branch has been force-pushed with the fixed commits. If you had local changes, you may need to `git pull --rebase`.'
              ].join('\n')
            });

  handle-dependabot:
    name: Handle Dependabot PR
    runs-on: ubuntu-latest
    # Only run for dependabot PRs
    if: |
      github.actor == 'dependabot[bot]' &&
      github.event.pull_request.head.repo.full_name == github.repository
    env:
      AUTOFIX_GPG_PRIVATE_KEY: ${{ secrets.AUTOFIX_GPG_PRIVATE_KEY }}
      AUTOFIX_GPG_PASSPHRASE: ${{ secrets.AUTOFIX_GPG_PASSPHRASE }}
      AUTOFIX_BOT_NAME: AiDotNetAutofixBot
      AUTOFIX_BOT_EMAIL: autofix-bot@ooples.com

    steps:
      - name: Checkout code
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6
        with:
          ref: ${{ github.head_ref }}
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
          persist-credentials: false

      - name: Import GPG key for signed commits
        if: env.AUTOFIX_GPG_PRIVATE_KEY != ''
        uses: crazy-max/ghaction-import-gpg@e89d40939c28e39f97cf32126055eeae86ba74ec # v6
        with:
          gpg_private_key: ${{ env.AUTOFIX_GPG_PRIVATE_KEY }}
          passphrase: ${{ env.AUTOFIX_GPG_PASSPHRASE }}
          git_user_signingkey: true
          git_commit_gpgsign: true

      - name: Configure Git
        env:
          AUTOFIX_PAT: ${{ secrets.AUTOFIX_PAT }}
        run: |
          if [ -n "$AUTOFIX_PAT" ]; then
            git config user.name "$AUTOFIX_BOT_NAME"
            git config user.email "$AUTOFIX_BOT_EMAIL"
          else
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
          fi

      - name: Get dependabot commit
        id: get-commit
        run: |
          BASE_BRANCH="${{ github.base_ref }}"
          git fetch origin "$BASE_BRANCH"

          # Get the dependabot commit
          COMMIT_SHA=$(git rev-list "origin/$BASE_BRANCH..HEAD" | head -1)
          COMMIT_MSG=$(git log -1 --format=%B "$COMMIT_SHA")
          FIRST_LINE=$(echo "$COMMIT_MSG" | head -1)

          echo "commit_sha=$COMMIT_SHA" >> $GITHUB_OUTPUT
          echo "first_line=$FIRST_LINE" >> $GITHUB_OUTPUT

          echo "Found dependabot commit: $FIRST_LINE"

      - name: Check if commit needs fixing
        id: check-needs-fix
        run: |
          FIRST_LINE="${{ steps.get-commit.outputs.first_line }}"
          NEEDS_FIX=false

          # Check if it follows our allowed format for deps
          if [[ "$FIRST_LINE" =~ ^deps:.* ]]; then
            # Check if description is lowercase
            DESCRIPTION=$(echo "$FIRST_LINE" | cut -d':' -f2- | sed 's/^ *//')
            if [[ "$DESCRIPTION" =~ ^[A-Z].* ]]; then
              NEEDS_FIX=true
              # Fix to lowercase
              FIXED_DESCRIPTION=$(echo "$DESCRIPTION" | sed 's/./\L&/')
              NEW_SUBJECT="deps: $FIXED_DESCRIPTION"
              echo "new_subject=$NEW_SUBJECT" >> $GITHUB_OUTPUT
            fi
          fi

          echo "needs_fix=$NEEDS_FIX" >> $GITHUB_OUTPUT

      - name: Fix dependabot commit
        if: steps.check-needs-fix.outputs.needs_fix == 'true'
        run: |
          if [ -z "$AUTOFIX_GPG_PRIVATE_KEY" ]; then
            echo "::error::Repository rules require signed commits. Configure secrets AUTOFIX_GPG_PRIVATE_KEY and AUTOFIX_GPG_PASSPHRASE so this workflow can create signed rewritten commits."
            exit 1
          fi

          COMMIT_SHA="${{ steps.get-commit.outputs.commit_sha }}"
          NEW_SUBJECT="${{ steps.check-needs-fix.outputs.new_subject }}"
          COMMIT_MSG=$(git log -1 --format=%B "$COMMIT_SHA")

          # Get the body (everything after first line and blank line)
          BODY=$(echo "$COMMIT_MSG" | tail -n +3)

          # Create new commit message
          if [ -n "$BODY" ]; then
            NEW_MSG="$NEW_SUBJECT\n\n$BODY"
          else
            NEW_MSG="$NEW_SUBJECT"
          fi

          # Amend the commit using printf for better portability
          printf '%b\n' "$NEW_MSG" | git commit --amend --file=-

      - name: Force push fix
        if: steps.check-needs-fix.outputs.needs_fix == 'true'
        env:
          HEAD_REF: ${{ github.head_ref }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          AUTOFIX_PAT: ${{ secrets.AUTOFIX_PAT }}
        run: |
          BRANCH="$HEAD_REF"
          git checkout -B "$BRANCH"
          push_with_token () {
            local token="$1"
            git remote set-url origin "https://x-access-token:${token}@github.com/${GITHUB_REPOSITORY}.git"
            git push origin "$BRANCH" --force-with-lease
          }

          if [ -n "$AUTOFIX_PAT" ]; then
            echo "Attempting push using AUTOFIX_PAT..."
            if push_with_token "$AUTOFIX_PAT"; then
              exit 0
            fi
            echo "::warning::Push using AUTOFIX_PAT failed. Falling back to GITHUB_TOKEN."
          else
            echo "::warning::AUTOFIX_PAT is not set. Downstream PR checks may not rerun automatically after this workflow force-pushes."
          fi

          echo "Attempting push using GITHUB_TOKEN..."
          push_with_token "$GITHUB_TOKEN"

      - name: Comment on PR
        if: steps.check-needs-fix.outputs.needs_fix == 'true'
        uses: actions/github-script@f28e40c7f34bde8b3046d885e986cb6290c5673b # v7
        env:
          ORIGINAL_SUBJECT: ${{ steps.get-commit.outputs.first_line }}
          NEW_SUBJECT: ${{ steps.check-needs-fix.outputs.new_subject }}
        with:
          script: |
            const originalSubject = process.env.ORIGINAL_SUBJECT ?? '';
            const newSubject = process.env.NEW_SUBJECT ?? '';
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,

              body: [
                '### Dependabot Commit Message Fixed',
                '',
                "The commitlint check failed because the dependabot commit message didn't follow the required format.",
                '',
                '**Action taken** - Fixed the subject line to be lowercase.',
                '',
                '**Original:** ' + '`' + originalSubject + '`',
                '**Fixed:** ' + '`' + newSubject + '`',
                '',
                'The PR branch has been force-pushed with the fixed commit.'
              ].join('\\n')
            });
