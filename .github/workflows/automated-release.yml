name: Automated Release Pipeline

on:
  push:
    branches:
      - main
      - master

permissions:
  contents: write
  issues: write
  pull-requests: write
  id-token: write

jobs:
  version-and-build:
    name: Version and Build
    runs-on: ubuntu-latest
    outputs:
      package_version: ${{ steps.version.outputs.version }}
      changelog: ${{ steps.version.outputs.changelog }}
      should_release: ${{ steps.version.outputs.should_release }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all history for accurate versioning

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 8.0.x

      - name: Determine version from conventional commits
        id: version
        run: |
          #!/bin/bash
          set -e

          echo "=== Automated Semantic Versioning from Conventional Commits ==="

          # Get the latest tag, default to 0.0.0 if none exists
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "Latest tag: $LATEST_TAG"

          # Remove 'v' prefix if present
          CURRENT_VERSION=${LATEST_TAG#v}
          echo "Current version: $CURRENT_VERSION"

          # Parse version components
          IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"
          # Remove any pre-release suffix from PATCH (e.g., "5-preview" -> "5")
          PATCH=${PATCH%%-*}

          echo "Parsed version: $MAJOR.$MINOR.$PATCH"

          # Get commits since last tag
          if git rev-parse "$LATEST_TAG" >/dev/null 2>&1; then
            COMMITS=$(git log "$LATEST_TAG..HEAD" --oneline --no-merges)
          else
            COMMITS=$(git log --oneline --no-merges)
          fi

          echo "=== Commits since last tag ==="
          echo "$COMMITS"
          echo "==========================="

          # Initialize bump type
          BUMP_TYPE="none"

          # Check for BREAKING CHANGE (triggers MAJOR bump)
          # Supports both "BREAKING CHANGE:" footer and "!" notation (e.g., feat!:, fix(scope)!:)
          if echo "$COMMITS" | grep -iE "(BREAKING CHANGE:|BREAKING:|^[a-f0-9]+ [a-z]+(\([^)]*\))?!:)" > /dev/null; then
            BUMP_TYPE="major"
            echo "Found BREAKING CHANGE - will bump MAJOR version"
          fi

          # Check for feat: (triggers MINOR bump if no BREAKING CHANGE)
          if [ "$BUMP_TYPE" = "none" ] && echo "$COMMITS" | grep -iE "^[a-f0-9]+ feat(\(.*\))?:" > /dev/null; then
            BUMP_TYPE="minor"
            echo "Found feat: commits - will bump MINOR version"
          fi

          # Check for fix:, refactor:, perf:, docs: (triggers MINOR bump per requirements)
          if [ "$BUMP_TYPE" = "none" ] && echo "$COMMITS" | grep -iE "^[a-f0-9]+ (fix|refactor|perf|docs)(\(.*\))?:" > /dev/null; then
            BUMP_TYPE="minor"
            echo "Found fix:/refactor:/perf:/docs: commits - will bump MINOR version"
          fi

          # Apply version bump
          case $BUMP_TYPE in
            major)
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              echo "Bumping MAJOR: $CURRENT_VERSION -> $MAJOR.$MINOR.$PATCH"
              ;;
            minor)
              MINOR=$((MINOR + 1))
              PATCH=0
              echo "Bumping MINOR: $CURRENT_VERSION -> $MAJOR.$MINOR.$PATCH"
              ;;
            none)
              echo "No conventional commits found, no version bump"
              echo "should_release=false" >> $GITHUB_OUTPUT
              echo "version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
              echo "changelog=No release needed - no conventional commits found" >> $GITHUB_OUTPUT
              exit 0
              ;;
          esac

          NEW_VERSION="$MAJOR.$MINOR.$PATCH"
          echo "New version: $NEW_VERSION"

          # Generate changelog
          echo "=== Generating Changelog ==="
          CHANGELOG="## Changes in v$NEW_VERSION"$'\n\n'

          # Breaking changes
          BREAKING=$(echo "$COMMITS" | grep -iE "BREAKING CHANGE:|BREAKING:" || true)
          if [ -n "$BREAKING" ]; then
            CHANGELOG+="### Breaking Changes"$'\n'
            while IFS= read -r line; do
              CHANGELOG+="- ${line#* }"$'\n'
            done < <(echo "$BREAKING")
            CHANGELOG+=$'\n'
          fi

          # Features
          FEATURES=$(echo "$COMMITS" | grep -iE "^[a-f0-9]+ feat(\(.*\))?:" || true)
          if [ -n "$FEATURES" ]; then
            CHANGELOG+="### Features"$'\n'
            while IFS= read -r line; do
              MSG=$(echo "$line" | sed -E 's/^[a-f0-9]+ feat(\(.*\))?: //')
              CHANGELOG+="- $MSG"$'\n'
            done < <(echo "$FEATURES")
            CHANGELOG+=$'\n'
          fi

          # Fixes
          FIXES=$(echo "$COMMITS" | grep -iE "^[a-f0-9]+ fix(\(.*\))?:" || true)
          if [ -n "$FIXES" ]; then
            CHANGELOG+="### Bug Fixes"$'\n'
            while IFS= read -r line; do
              MSG=$(echo "$line" | sed -E 's/^[a-f0-9]+ fix(\(.*\))?: //')
              CHANGELOG+="- $MSG"$'\n'
            done < <(echo "$FIXES")
            CHANGELOG+=$'\n'
          fi

          # Performance improvements
          PERF=$(echo "$COMMITS" | grep -iE "^[a-f0-9]+ perf(\(.*\))?:" || true)
          if [ -n "$PERF" ]; then
            CHANGELOG+="### Performance Improvements"$'\n'
            while IFS= read -r line; do
              MSG=$(echo "$line" | sed -E 's/^[a-f0-9]+ perf(\(.*\))?: //')
              CHANGELOG+="- $MSG"$'\n'
            done < <(echo "$PERF")
            CHANGELOG+=$'\n'
          fi

          # Refactoring
          REFACTOR=$(echo "$COMMITS" | grep -iE "^[a-f0-9]+ refactor(\(.*\))?:" || true)
          if [ -n "$REFACTOR" ]; then
            CHANGELOG+="### Code Refactoring"$'\n'
            while IFS= read -r line; do
              MSG=$(echo "$line" | sed -E 's/^[a-f0-9]+ refactor(\(.*\))?: //')
              CHANGELOG+="- $MSG"$'\n'
            done < <(echo "$REFACTOR")
            CHANGELOG+=$'\n'
          fi

          # Documentation
          DOCS=$(echo "$COMMITS" | grep -iE "^[a-f0-9]+ docs(\(.*\))?:" || true)
          if [ -n "$DOCS" ]; then
            CHANGELOG+="### Documentation"$'\n'
            while IFS= read -r line; do
              MSG=$(echo "$line" | sed -E 's/^[a-f0-9]+ docs(\(.*\))?: //')
              CHANGELOG+="- $MSG"$'\n'
            done < <(echo "$DOCS")
            CHANGELOG+=$'\n'
          fi

          echo "$CHANGELOG"

          # Output results
          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "should_release=true" >> $GITHUB_OUTPUT

          # Save changelog to file for multi-line output
          echo "$CHANGELOG" > /tmp/changelog.txt
          {
            echo 'changelog<<EOF'
            cat /tmp/changelog.txt
            echo EOF
          } >> $GITHUB_OUTPUT

      - name: Restore dependencies
        if: steps.version.outputs.should_release == 'true'
        run: dotnet restore

      - name: Build
        if: steps.version.outputs.should_release == 'true'
        run: dotnet build -c Release --no-restore

  # Parallel test execution using matrix strategy
  test:
    name: Test (${{ matrix.project }})
    runs-on: ubuntu-latest
    needs: version-and-build
    if: needs.version-and-build.outputs.should_release == 'true'
    strategy:
      fail-fast: false
      matrix:
        project:
          - tests/AiDotNet.Tests/AiDotNetTests.csproj
          - tests/AiDotNet.Serving.Tests/AiDotNet.Serving.Tests.csproj
          - tests/AiDotNet.Tensors.Tests/AiDotNet.Tensors.Tests.csproj
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 8.0.x

      - name: Restore and build
        run: |
          dotnet restore
          dotnet build -c Release --no-restore

      - name: Run tests for ${{ matrix.project }}
        run: |
          dotnet test ${{ matrix.project }} \
            -c Release \
            --no-build \
            --collect:"XPlat Code Coverage" \
            --results-directory ./TestResults \
            --logger "trx;LogFileName=test-results.trx"

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results-${{ strategy.job-index }}
          path: ./TestResults/
          retention-days: 7

  # Pack NuGet after all tests pass
  pack:
    name: Pack NuGet
    runs-on: ubuntu-latest
    needs: [version-and-build, test]
    if: needs.version-and-build.outputs.should_release == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 8.0.x

      - name: Restore and Build
        run: |
          dotnet restore
          dotnet build -c Release --no-restore

      - name: Pack NuGet
        run: |
          if [ -f "src/AiDotNet.csproj" ]; then
            dotnet pack src/AiDotNet.csproj -c Release -o out /p:PackageVersion=${{ needs.version-and-build.outputs.package_version }}
            echo "Package created: AiDotNet.${{ needs.version-and-build.outputs.package_version }}.nupkg"
          else
            echo "Error: src/AiDotNet.csproj not found"
            exit 1
          fi

      - name: Verify TFMs in package (net471, net8.0)
        run: |
          set -e
          shopt -s nullglob
          pkgs=(out/*.nupkg)
          if [ ${#pkgs[@]} -eq 0 ]; then
            echo "Error: No packages found in out/"
            exit 1
          fi

          for pkg in "${pkgs[@]}"; do
            echo "Inspecting $pkg"
            files=$(unzip -Z1 "$pkg")

            # Check for net471 and net8.0 (matching csproj TargetFrameworks)
            for tfm in net471 net8.0; do
              if ! echo "$files" | grep -qE "^lib/${tfm}/.+\\.dll$"; then
                echo "Error: Missing ${tfm} lib in package"
                exit 1
              else
                echo "Found ${tfm} in package"
              fi
            done
          done

          echo "All required TFMs verified successfully"

      - name: Upload package artifact
        uses: actions/upload-artifact@v4
        with:
          name: nuget-package-${{ github.sha }}
          path: out/*.nupkg
          if-no-files-found: error

  publish-nuget:
    name: Publish to NuGet
    runs-on: ubuntu-latest
    needs: [version-and-build, pack]
    if: needs.version-and-build.outputs.should_release == 'true'
    steps:
      - name: Download package
        uses: actions/download-artifact@v4
        with:
          name: nuget-package-${{ github.sha }}
          path: out/

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 8.0.x

      - name: Push to NuGet
        run: |
          shopt -s nullglob
          pkgs=(out/*.nupkg)

          if [ ${#pkgs[@]} -eq 0 ]; then
            echo "Error: No .nupkg files found in out/ directory"
            exit 1
          fi

          for pkg in "${pkgs[@]}"; do
            echo "Publishing $pkg to NuGet..."
            dotnet nuget push "$pkg" \
              --api-key ${{ secrets.NUGET_API_KEY }} \
              --source https://api.nuget.org/v3/index.json \
              --skip-duplicate

            if [ $? -eq 0 ]; then
              echo "Successfully published $pkg"
            else
              echo "Warning: Failed to publish $pkg (may already exist)"
            fi
          done

  github-release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: [version-and-build, publish-nuget]
    if: needs.version-and-build.outputs.should_release == 'true'
    steps:
      - name: Download package
        uses: actions/download-artifact@v4
        with:
          name: nuget-package-${{ github.sha }}
          path: out/

      - name: List artifacts
        run: ls -lah out/

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ needs.version-and-build.outputs.package_version }}
          name: Release v${{ needs.version-and-build.outputs.package_version }}
          body: ${{ needs.version-and-build.outputs.changelog }}
          files: out/*.nupkg
          draft: false
          prerelease: false
          make_latest: true
          generate_release_notes: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
