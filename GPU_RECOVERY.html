<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>GPU Device Loss Recovery - Phase B | AiDotNet Documentation </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="GPU Device Loss Recovery - Phase B | AiDotNet Documentation ">
      
      
      <link rel="icon" href="favicon.ico">
      <link rel="stylesheet" href="public/docfx.min.css">
      <link rel="stylesheet" href="public/main.css">
      <meta name="docfx:navrel" content="toc.html">
      <meta name="docfx:tocrel" content="toc.html">
      
      <meta name="docfx:rel" content="">
      
      
      <meta name="docfx:docurl" content="https://github.com/ooples/AiDotNet/blob/master/docs/GPU_RECOVERY.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="index.html">
            <img id="logo" class="svg" src="logo.svg" alt="AiDotNet">
            AiDotNet
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">

      <div class="content">
        <div class="actionbar">

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="gpu-device-loss-recovery---phase-b">GPU Device Loss Recovery - Phase B</h1>

<h2 id="overview">Overview</h2>
<p>This document describes the GPU device loss recovery implementation for AiDotNet (Phase B: US-GPU-020). The recovery system provides graceful degradation, automatic retry mechanisms, and comprehensive health monitoring.</p>
<h2 id="recovery-strategy">Recovery Strategy</h2>
<p><strong>GpuEngine implements intelligent GPU recovery</strong>:</p>
<ul>
<li>✅ Automatic detection of GPU device failures</li>
<li>✅ Graceful fallback to CPU operations</li>
<li>✅ Automatic recovery attempts with backoff</li>
<li>✅ Permanent disabling after repeated failures</li>
<li>✅ Comprehensive health diagnostics</li>
</ul>
<h2 id="recovery-mechanism">Recovery Mechanism</h2>
<h3 id="1-failure-detection-and-classification">1. Failure Detection and Classification</h3>
<p><strong>Device-level failures</strong> (critical):</p>
<ul>
<li>GPU driver crashes</li>
<li>CUDA/OpenCL device errors</li>
<li>GPU memory corruption</li>
<li>Accelerator unavailability</li>
</ul>
<p><strong>Operation-level failures</strong> (transient):</p>
<ul>
<li>Out of memory (can recover)</li>
<li>Kernel timeout (may be transient)</li>
<li>Temporary driver issues</li>
</ul>
<h3 id="2-recovery-parameters">2. Recovery Parameters</h3>
<pre><code class="lang-csharp">// Configurable recovery parameters
private const int MaxRecoveryAttempts = 3;
private static readonly TimeSpan RecoveryBackoffPeriod = TimeSpan.FromSeconds(30);
</code></pre>
<p><strong>Default behavior</strong>:</p>
<ul>
<li><strong>Maximum attempts</strong>: 3 consecutive failures before permanent disable</li>
<li><strong>Backoff period</strong>: 30 seconds between recovery attempts</li>
<li><strong>Failure tracking</strong>: Consecutive failures reset on success</li>
</ul>
<h3 id="3-recovery-state-machine">3. Recovery State Machine</h3>
<pre><code>[Healthy GPU]
      |
      | (Failure detected)
      v
[Record Failure] --&gt; Failure count: 1
      |
      | (30s backoff)
      v
[Attempt Recovery]
      |
      ├─ Success --&gt; [Healthy GPU] (Reset count to 0)
      |
      └─ Failure --&gt; [Record Failure] --&gt; Failure count: 2
            |
            | (30s backoff)
            v
       [Attempt Recovery]
            |
            ├─ Success --&gt; [Healthy GPU]
            |
            └─ Failure --&gt; [Record Failure] --&gt; Failure count: 3
                  |
                  v
           [Permanently Disabled] (All future ops use CPU)
</code></pre>
<h2 id="implementation-details">Implementation Details</h2>
<h3 id="recordgpufailure">RecordGpuFailure()</h3>
<p>Tracks GPU failures and determines recovery eligibility:</p>
<pre><code class="lang-csharp">private bool RecordGpuFailure(Exception exception)
{
    lock (_recoveryLock)
    {
        _consecutiveFailures++;
        _lastFailureTime = DateTime.UtcNow;

        Console.WriteLine($&quot;[GpuEngine] GPU failure #{_consecutiveFailures}: {exception.Message}&quot;);

        // Permanent disable after max attempts
        if (_consecutiveFailures &gt;= MaxRecoveryAttempts)
        {
            _gpuHealthy = false;
            Console.WriteLine($&quot;[GpuEngine] GPU permanently disabled after {_consecutiveFailures} consecutive failures.&quot;);
            return true;
        }

        // Temporary disable, allow recovery
        Console.WriteLine($&quot;[GpuEngine] Recovery attempt {_consecutiveFailures}/{MaxRecoveryAttempts} will be tried after backoff.&quot;);
        return false;
    }
}
</code></pre>
<p><strong>Features</strong>:</p>
<ul>
<li>Thread-safe failure counting</li>
<li>Timestamp tracking for backoff calculation</li>
<li>Console logging for diagnostics</li>
<li>Permanent vs. temporary disable differentiation</li>
</ul>
<h3 id="attemptgpurecovery">AttemptGpuRecovery()</h3>
<p>Attempts to restore GPU functionality after backoff period:</p>
<pre><code class="lang-csharp">private bool AttemptGpuRecovery()
{
    lock (_recoveryLock)
    {
        // Don't recover if permanently disabled
        if (!_gpuHealthy)
            return false;

        // Enforce backoff period
        var timeSinceFailure = DateTime.UtcNow - _lastFailureTime;
        if (timeSinceFailure &lt; RecoveryBackoffPeriod)
            return false; // Still in backoff

        // Test GPU responsiveness
        try
        {
            lock (_gpuLock)
            {
                _accelerator.Synchronize(); // Test operation
            }

            // Recovery successful!
            _consecutiveFailures = 0;
            _lastFailureTime = DateTime.MinValue;
            Console.WriteLine(&quot;[GpuEngine] GPU recovery successful!&quot;);
            return true;
        }
        catch (Exception ex)
        {
            RecordGpuFailure(ex); // Recursive failure tracking
            return false;
        }
    }
}
</code></pre>
<p><strong>Recovery conditions</strong>:</p>
<ol>
<li>GPU not permanently disabled</li>
<li>Backoff period has elapsed</li>
<li>Accelerator is non-null</li>
<li>Synchronize() test succeeds</li>
</ol>
<h3 id="getgpuhealthdiagnostics">GetGpuHealthDiagnostics()</h3>
<p>Provides comprehensive health status information:</p>
<pre><code class="lang-csharp">public string GetGpuHealthDiagnostics()
{
    var diagnostics = new StringBuilder();
    diagnostics.AppendLine(&quot;GPU Health Diagnostics:&quot;);
    diagnostics.AppendLine($&quot;  Healthy: {_gpuHealthy}&quot;);
    diagnostics.AppendLine($&quot;  Consecutive Failures: {_consecutiveFailures}/{MaxRecoveryAttempts}&quot;);
    diagnostics.AppendLine($&quot;  Last Failure: {(_lastFailureTime == DateTime.MinValue ? &quot;Never&quot; : _lastFailureTime.ToString())}&quot;);

    if (_lastFailureTime != DateTime.MinValue)
    {
        var timeSinceFailure = DateTime.UtcNow - _lastFailureTime;
        diagnostics.AppendLine($&quot;  Time Since Failure: {timeSinceFailure.TotalSeconds:F1}s&quot;);

        if (timeSinceFailure &lt; RecoveryBackoffPeriod)
        {
            var timeUntilRecovery = RecoveryBackoffPeriod - timeSinceFailure;
            diagnostics.AppendLine($&quot;  Recovery Available In: {timeUntilRecovery.TotalSeconds:F1}s&quot;);
        }
    }

    diagnostics.AppendLine($&quot;  Accelerator: {_accelerator.Name}&quot;);
    diagnostics.AppendLine($&quot;  Memory: {_accelerator.MemorySize / (1024.0 * 1024.0 * 1024.0):F2} GB&quot;);

    return diagnostics.ToString();
}
</code></pre>
<p><strong>Output example</strong>:</p>
<pre><code>GPU Health Diagnostics:
  Healthy: True
  Consecutive Failures: 0/3
  Last Failure: Never
  Accelerator: NVIDIA GeForce RTX 3080
  Memory: 10.00 GB
</code></pre>
<h3 id="checkandrecovergpuhealth">CheckAndRecoverGpuHealth()</h3>
<p>Public API for manual health checks and recovery:</p>
<pre><code class="lang-csharp">public bool CheckAndRecoverGpuHealth()
{
    if (_gpuHealthy)
        return true;

    // Attempt recovery if eligible
    return AttemptGpuRecovery();
}
</code></pre>
<h2 id="failure-scenarios">Failure Scenarios</h2>
<h3 id="scenario-1-transient-gpu-failure">Scenario 1: Transient GPU Failure</h3>
<p><strong>Timeline</strong>:</p>
<ol>
<li><strong>T=0s</strong>: GPU operation fails → Failure count: 1</li>
<li><strong>T=0-30s</strong>: All operations use CPU fallback</li>
<li><strong>T=30s</strong>: Recovery attempt succeeds</li>
<li><strong>T=30s+</strong>: GPU operations resume, failure count reset to 0</li>
</ol>
<p><strong>Behavior</strong>: Automatic recovery, minimal user impact</p>
<h3 id="scenario-2-intermittent-gpu-issues">Scenario 2: Intermittent GPU Issues</h3>
<p><strong>Timeline</strong>:</p>
<ol>
<li><strong>T=0s</strong>: GPU failure #1 → CPU fallback, backoff starts</li>
<li><strong>T=30s</strong>: Recovery attempt → Success</li>
<li><strong>T=45s</strong>: GPU failure #2 → CPU fallback, backoff starts</li>
<li><strong>T=75s</strong>: Recovery attempt → Success</li>
<li><strong>T=90s</strong>: Normal GPU operation</li>
</ol>
<p><strong>Behavior</strong>: Each success resets the failure counter</p>
<h3 id="scenario-3-permanent-gpu-loss">Scenario 3: Permanent GPU Loss</h3>
<p><strong>Timeline</strong>:</p>
<ol>
<li><strong>T=0s</strong>: GPU failure #1 → Backoff 30s</li>
<li><strong>T=30s</strong>: Recovery fails → Failure #2, backoff 30s</li>
<li><strong>T=60s</strong>: Recovery fails → Failure #3, backoff 30s</li>
<li><strong>T=90s</strong>: Recovery fails → <strong>Permanent disable</strong></li>
<li><strong>T=90s+</strong>: All operations permanently use CPU</li>
</ol>
<p><strong>Behavior</strong>: After 3 consecutive failures, GPU is permanently disabled</p>
<h3 id="scenario-4-gpu-driver-crash">Scenario 4: GPU Driver Crash</h3>
<p><strong>Detection</strong>: Exception messages containing &quot;device&quot; or &quot;accelerator&quot;</p>
<p><strong>Response</strong>:</p>
<ol>
<li>Immediately record failure</li>
<li>Fall back to CPU for current operation</li>
<li>Enter recovery backoff period</li>
<li>Attempt recovery after 30 seconds</li>
</ol>
<h2 id="usage-patterns">Usage Patterns</h2>
<h3 id="monitoring-gpu-health">Monitoring GPU Health</h3>
<pre><code class="lang-csharp">var gpuEngine = new GpuEngine();

// Check current health status
var diagnostics = gpuEngine.GetGpuHealthDiagnostics();
Console.WriteLine(diagnostics);

// Output:
// GPU Health Diagnostics:
//   Healthy: True
//   Consecutive Failures: 0/3
//   Last Failure: Never
//   Accelerator: NVIDIA GeForce RTX 3080
//   Memory: 10.00 GB
</code></pre>
<h3 id="manual-recovery-trigger">Manual Recovery Trigger</h3>
<pre><code class="lang-csharp">// Manually check and attempt recovery
bool isHealthy = gpuEngine.CheckAndRecoverGpuHealth();

if (isHealthy)
{
    Console.WriteLine(&quot;GPU is healthy and ready for operations&quot;);
}
else
{
    Console.WriteLine(&quot;GPU is unavailable - using CPU fallback&quot;);
}
</code></pre>
<h3 id="periodic-health-monitoring">Periodic Health Monitoring</h3>
<pre><code class="lang-csharp">// Background health monitoring (recommended for long-running applications)
var healthCheckTimer = new System.Timers.Timer(60000); // Every 60 seconds
healthCheckTimer.Elapsed += (sender, e) =&gt;
{
    var diagnostics = gpuEngine.GetGpuHealthDiagnostics();
    logger.LogInformation(diagnostics);

    if (!gpuEngine.SupportsGpu)
    {
        logger.LogWarning(&quot;GPU unavailable - attempting recovery&quot;);
        gpuEngine.CheckAndRecoverGpuHealth();
    }
};
healthCheckTimer.Start();
</code></pre>
<h3 id="handling-permanent-gpu-loss">Handling Permanent GPU Loss</h3>
<pre><code class="lang-csharp">// Detect permanent GPU disable
if (!gpuEngine.SupportsGpu)
{
    var diagnostics = gpuEngine.GetGpuHealthDiagnostics();

    if (diagnostics.Contains(&quot;Consecutive Failures: 3/3&quot;))
    {
        // GPU permanently disabled
        logger.LogError(&quot;GPU has been permanently disabled after 3 failures&quot;);
        logger.LogInformation(&quot;All operations will use CPU fallback&quot;);

        // Consider switching to CPU engine for better performance
        var cpuEngine = new CpuEngine();
        // Use cpuEngine for all future operations
    }
}
</code></pre>
<h2 id="testing">Testing</h2>
<h3 id="recovery-test-suite">Recovery Test Suite</h3>
<p>Location: <code>/tests/AiDotNet.Tests/Recovery/GpuRecoveryTests.cs</code></p>
<p><strong>Test Coverage</strong>:</p>
<ol>
<li>Health diagnostics availability</li>
<li>CheckAndRecoverGpuHealth when healthy</li>
<li>Graceful CPU fallback on GPU unavailability</li>
<li>SupportsGpu property accuracy</li>
<li>Multiple operations after GPU loss</li>
<li>Health status consistency</li>
<li>Diagnostics accuracy</li>
<li>Post-dispose behavior</li>
<li>Concurrent health checks thread safety</li>
</ol>
<p><strong>Running tests</strong>:</p>
<pre><code class="lang-bash">dotnet test --filter &quot;FullyQualifiedName~GpuRecoveryTests&quot;
</code></pre>
<p><strong>Expected results</strong>:</p>
<ul>
<li>✅ All operations complete successfully (GPU or CPU fallback)</li>
<li>✅ Health diagnostics provide accurate information</li>
<li>✅ No exceptions from concurrent health checks</li>
<li>✅ CPU fallback works transparently</li>
</ul>
<h2 id="performance-impact">Performance Impact</h2>
<h3 id="recovery-overhead">Recovery Overhead</h3>
<p><strong>Failure detection</strong>: Negligible (exception handling only)
<strong>Failure recording</strong>: ~1 microsecond (lock + increment + timestamp)
<strong>Recovery attempt</strong>: ~10-100 milliseconds (Synchronize() test)
<strong>Diagnostics generation</strong>: ~100 microseconds (string building)</p>
<h3 id="cpu-fallback-performance">CPU Fallback Performance</h3>
<p>When GPU is unavailable:</p>
<ul>
<li>Small operations (&lt; 10K elements): <strong>No performance difference</strong> (would use CPU anyway)</li>
<li>Large operations (&gt; 100K elements): <strong>10-100x slower</strong> (no GPU acceleration)</li>
</ul>
<p><strong>Mitigation</strong>: Permanent GPU disable after 3 failures prevents repeated overhead</p>
<h2 id="best-practices">Best Practices</h2>
<h3 id="-do">✅ DO</h3>
<ul>
<li><strong>Monitor GPU health</strong> in production applications</li>
<li><strong>Log diagnostics</strong> periodically for troubleshooting</li>
<li><strong>Handle permanent GPU loss</strong> gracefully (switch to CpuEngine)</li>
<li><strong>Trust the recovery mechanism</strong> - it's automatic</li>
<li><strong>Use CheckAndRecoverGpuHealth()</strong> to force recovery checks</li>
</ul>
<h3 id="-dont">❌ DON'T</h3>
<ul>
<li><strong>Don't manually set _gpuHealthy</strong> - use RecordGpuFailure()</li>
<li><strong>Don't bypass CPU fallback</strong> - it's your safety net</li>
<li><strong>Don't retry immediately</strong> - respect the backoff period</li>
<li><strong>Don't ignore permanent disable</strong> - switch to CPU engine</li>
<li><strong>Don't assume GPU is always available</strong> - check SupportsGpu</li>
</ul>
<h2 id="troubleshooting">Troubleshooting</h2>
<h3 id="gpu-keeps-failing-and-recovering">GPU Keeps Failing and Recovering</h3>
<p><strong>Symptoms</strong>: Repeated failure → recovery cycles</p>
<p><strong>Possible causes</strong>:</p>
<ol>
<li>GPU thermal throttling</li>
<li>Insufficient power supply</li>
<li>Driver instability</li>
<li>Faulty hardware</li>
</ol>
<p><strong>Solutions</strong>:</p>
<ul>
<li>Check GPU temperature (<code>nvidia-smi</code> or GPU-Z)</li>
<li>Update GPU drivers</li>
<li>Reduce GPU load (lower batch sizes)</li>
<li>Check PSU wattage</li>
<li>Run GPU stress test (FurMark, MSI Kombustor)</li>
</ul>
<h3 id="gpu-permanently-disabled-too-quickly">GPU Permanently Disabled Too Quickly</h3>
<p><strong>Symptoms</strong>: GPU disabled after 3 failures within minutes</p>
<p><strong>Tuning</strong>: Adjust recovery parameters (requires code modification)</p>
<pre><code class="lang-csharp">private const int MaxRecoveryAttempts = 5; // Increase attempts
private static readonly TimeSpan RecoveryBackoffPeriod = TimeSpan.FromMinutes(1); // Longer backoff
</code></pre>
<h3 id="recovery-never-succeeds">Recovery Never Succeeds</h3>
<p><strong>Symptoms</strong>: Recovery attempts always fail</p>
<p><strong>Debug steps</strong>:</p>
<pre><code class="lang-csharp">// Enable detailed recovery logging
var diagnostics = gpuEngine.GetGpuHealthDiagnostics();
Console.WriteLine(diagnostics);

// Check if accelerator is null
if (!gpuEngine.SupportsGpu)
{
    Console.WriteLine(&quot;Accelerator is null or unavailable&quot;);
    // Likely hardware/driver issue
}
</code></pre>
<h3 id="high-cpu-usage-after-gpu-disable">High CPU Usage After GPU Disable</h3>
<p><strong>Symptoms</strong>: 100% CPU usage after GPU becomes unavailable</p>
<p><strong>Explanation</strong>: Large operations now run on CPU</p>
<p><strong>Solutions</strong>:</p>
<ol>
<li>Reduce operation sizes</li>
<li>Switch to CpuEngine (better CPU optimizations)</li>
<li>Fix GPU issue and restart application</li>
<li>Use adaptive thresholds to avoid large CPU operations</li>
</ol>
<h2 id="monitoring-and-metrics">Monitoring and Metrics</h2>
<h3 id="recommended-metrics-to-track">Recommended Metrics to Track</h3>
<ol>
<li><strong>GPU Availability</strong>: <code>gpuEngine.SupportsGpu</code> (boolean)</li>
<li><strong>Failure Count</strong>: Parse from <code>GetGpuHealthDiagnostics()</code></li>
<li><strong>Time Since Last Failure</strong>: Calculate from diagnostics</li>
<li><strong>Recovery Success Rate</strong>: Track successful vs. failed recoveries</li>
<li><strong>CPU Fallback Frequency</strong>: Count operations using CPU</li>
</ol>
<h3 id="integration-with-monitoring-systems">Integration with Monitoring Systems</h3>
<pre><code class="lang-csharp">// Prometheus metrics example
public class GpuMetrics
{
    private static readonly Counter GpuFailures = Metrics.CreateCounter(
        &quot;aidotnet_gpu_failures_total&quot;, &quot;Total GPU failures&quot;);

    private static readonly Gauge GpuHealthy = Metrics.CreateGauge(
        &quot;aidotnet_gpu_healthy&quot;, &quot;GPU health status (1=healthy, 0=unhealthy)&quot;);

    public static void RecordFailure()
    {
        GpuFailures.Inc();
        GpuHealthy.Set(0);
    }

    public static void RecordRecovery()
    {
        GpuHealthy.Set(1);
    }
}
</code></pre>
<h2 id="future-enhancements">Future Enhancements</h2>
<h3 id="planned-improvements">Planned Improvements</h3>
<ol>
<li><p><strong>Configurable recovery parameters</strong>:</p>
<ul>
<li>Allow users to set max attempts and backoff period</li>
<li>Per-operation recovery policies</li>
</ul>
</li>
<li><p><strong>Telemetry integration</strong>:</p>
<ul>
<li>Built-in metrics export (Prometheus, OpenTelemetry)</li>
<li>Automatic alerting on repeated failures</li>
</ul>
</li>
<li><p><strong>GPU device reconnection</strong>:</p>
<ul>
<li>Support for hot-plug GPU devices</li>
<li>Automatic reinitialization when new GPU detected</li>
</ul>
</li>
<li><p><strong>Partial GPU degradation</strong>:</p>
<ul>
<li>Detect and handle partial GPU failures</li>
<li>Use GPU for some operations while failing others</li>
</ul>
</li>
<li><p><strong>Multi-GPU failover</strong>:</p>
<ul>
<li>Automatically switch to secondary GPU on primary failure</li>
<li>Load balancing across available GPUs</li>
</ul>
</li>
</ol>
<h2 id="references">References</h2>
<ul>
<li><strong>CUDA Error Handling</strong>: <a href="https://docs.nvidia.com/cuda/cuda-runtime-api/group__CUDART__ERROR.html">https://docs.nvidia.com/cuda/cuda-runtime-api/group__CUDART__ERROR.html</a></li>
<li><strong>Exponential Backoff</strong>: <a href="https://en.wikipedia.org/wiki/Exponential_backoff">https://en.wikipedia.org/wiki/Exponential_backoff</a></li>
</ul>
<hr>
<p><strong>Last Updated</strong>: 2025-01-17
<strong>Phase</strong>: B - GPU Production Implementation
<strong>Status</strong>: US-GPU-020 Complete</p>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/ooples/AiDotNet/blob/master/docs/GPU_RECOVERY.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          AiDotNet - Enterprise AI/ML Library for .NET
        </div>
      </div>
    </footer>
  </body>
</html>
