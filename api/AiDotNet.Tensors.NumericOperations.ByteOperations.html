<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Class ByteOperations | AiDotNet Documentation </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Class ByteOperations | AiDotNet Documentation ">
      
      <meta name="description" content="Provides mathematical operations for the byte data type.">
      <link rel="icon" href="../favicon.ico">
      <link rel="stylesheet" href="../public/docfx.min.css">
      <link rel="stylesheet" href="../public/main.css">
      <meta name="docfx:navrel" content="../toc.html">
      <meta name="docfx:tocrel" content="toc.html">
      
      <meta name="docfx:rel" content="../">
      
      
      <meta name="docfx:docurl" content="https://github.com/ooples/AiDotNet/new/master/apiSpec/new?filename=AiDotNet_Tensors_NumericOperations_ByteOperations.md&amp;value=---%0Auid%3A%20AiDotNet.Tensors.NumericOperations.ByteOperations%0Asummary%3A%20&#39;*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax&#39;%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="ManagedReference">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../index.html">
            <img id="logo" class="svg" src="../logo.svg" alt="AiDotNet">
            AiDotNet
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations">



  <h1 id="AiDotNet_Tensors_NumericOperations_ByteOperations" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations" class="text-break">
Class ByteOperations  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L31"><i class="bi bi-code-slash"></i></a>
  </h1>

  <div class="facts text-secondary">
    <dl><dt>Namespace</dt><dd><a class="xref" href="AiDotNet.html">AiDotNet</a>.<a class="xref" href="AiDotNet.Tensors.html">Tensors</a>.<a class="xref" href="AiDotNet.Tensors.NumericOperations.html">NumericOperations</a></dd></dl>
  <dl><dt>Assembly</dt><dd>AiDotNet.Tensors.dll</dd></dl>
  </div>

  <div class="markdown summary"><p>Provides mathematical operations for the byte data type.</p>
</div>
  <div class="markdown conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public class ByteOperations : INumericOperations&lt;byte&gt;, IVectorizedOperations&lt;byte&gt;</code></pre>
  </div>




  <dl class="typelist inheritance">
    <dt>Inheritance</dt>
    <dd>
      <div><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.object">object</a></div>
      <div><span class="xref">ByteOperations</span></div>
    </dd>
  </dl>

  <dl class="typelist implements">
    <dt>Implements</dt>
    <dd>
      <div><a class="xref" href="AiDotNet.Tensors.Interfaces.INumericOperations-1.html">INumericOperations</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</div>
      <div><a class="xref" href="AiDotNet.Tensors.Interfaces.IVectorizedOperations-1.html">IVectorizedOperations</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</div>
    </dd>
  </dl>


  <dl class="typelist inheritedMembers">
    <dt>Inherited Members</dt>
    <dd>
    <div>
      <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.object.equals#system-object-equals(system-object)">object.Equals(object)</a>
    </div>
    <div>
      <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.object.equals#system-object-equals(system-object-system-object)">object.Equals(object, object)</a>
    </div>
    <div>
      <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.object.gethashcode">object.GetHashCode()</a>
    </div>
    <div>
      <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.object.gettype">object.GetType()</a>
    </div>
    <div>
      <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.object.memberwiseclone">object.MemberwiseClone()</a>
    </div>
    <div>
      <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.object.referenceequals">object.ReferenceEquals(object, object)</a>
    </div>
    <div>
      <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.object.tostring">object.ToString()</a>
    </div>
  </dd></dl>




  <h2 id="AiDotNet_Tensors_NumericOperations_ByteOperations_remarks">Remarks</h2>
  <div class="markdown level0 remarks"><p>
This class implements the INumericOperations interface for the byte data type, providing
basic arithmetic operations, comparison methods, and mathematical functions. Due to the limited
range of the byte type (0-255), some operations may result in overflow or underflow, which
will wrap around according to the byte data type's behavior.
</p>
<p><b>For Beginners:</b> This class lets you perform math operations on byte values.
<p>A byte is a very small number type that can only hold values from 0 to 255.</p>
<p>Important things to know about bytes:</p>
<ul>
<li>When math operations result in values outside the 0-255 range, they &quot;wrap around&quot;</li>
<li>For example, 255 + 10 = 9 (not 265) because it exceeds the maximum and wraps around</li>
<li>This class handles all the math operations for bytes in AI.NET</li>
</ul>
<p>Think of this like a car odometer with only 3 digits - after 999 miles, it rolls over to 000.</p>

</div>


  <h2 class="section" id="properties">Properties
</h2>


  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_MaxValue_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.MaxValue*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_MaxValue" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.MaxValue">
  MaxValue
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L557"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Gets the maximum value a byte can represent.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public byte MaxValue { get; }</code></pre>
  </div>





  <h4 class="section">Property Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The maximum value of a byte, which is 255.</p>
</dd>
  </dl>




  <h4 class="section" id="AiDotNet_Tensors_NumericOperations_ByteOperations_MaxValue_remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>
This property returns the maximum value that can be represented by a byte, which is 255.
</p>
<p><b>For Beginners:</b> This property gives you the largest possible byte value.
<p>For bytes, the maximum value is 255.</p>
<p>This is useful when you need to work with the full range of byte values
or need to check against the maximum possible value.</p>

</div>




  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_MinValue_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.MinValue*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_MinValue" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.MinValue">
  MinValue
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L539"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Gets the minimum value a byte can represent.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public byte MinValue { get; }</code></pre>
  </div>





  <h4 class="section">Property Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The minimum value of a byte, which is 0.</p>
</dd>
  </dl>




  <h4 class="section" id="AiDotNet_Tensors_NumericOperations_ByteOperations_MinValue_remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>
This property returns the minimum value that can be represented by a byte, which is 0.
</p>
<p><b>For Beginners:</b> This property gives you the smallest possible byte value.
<p>For bytes, the minimum value is 0.</p>
<p>This is useful when you need to work with the full range of byte values
or need to check against the minimum possible value.</p>

</div>




  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_One_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.One*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_One" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.One">
  One
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L181"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Gets the byte representation of one.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public byte One { get; }</code></pre>
  </div>





  <h4 class="section">Property Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The value 1 as a byte.</p>
</dd>
  </dl>




  <h4 class="section" id="AiDotNet_Tensors_NumericOperations_ByteOperations_One_remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>
This property returns the byte representation of the value one, which is 1.
It is often used as a neutral element for multiplication.
</p>
<p><b>For Beginners:</b> This property provides the value one as a byte.
<p>One is a special value in mathematics:</p>
<ul>
<li>Multiplying any number by one gives the same number</li>
<li>It's useful as a starting point or increment value</li>
</ul>
<p>This property gives you a one that matches the byte type.</p>

</div>




  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_PrecisionBits_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.PrecisionBits*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_PrecisionBits" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.PrecisionBits">
  PrecisionBits
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L631"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Gets the number of bits used for precision in byte (8 bits).</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public int PrecisionBits { get; }</code></pre>
  </div>





  <h4 class="section">Property Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd></dd>
  </dl>








  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_SupportsCpuAcceleration_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.SupportsCpuAcceleration*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_SupportsCpuAcceleration" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.SupportsCpuAcceleration">
  SupportsCpuAcceleration
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L675"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Indicates whether this numeric type supports SIMD/CPU-accelerated operations.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public bool SupportsCpuAcceleration { get; }</code></pre>
  </div>





  <h4 class="section">Property Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.boolean">bool</a></dt>
    <dd></dd>
  </dl>




  <h4 class="section" id="AiDotNet_Tensors_NumericOperations_ByteOperations_SupportsCpuAcceleration_remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p><b>For Beginners:</b> SIMD (Single Instruction Multiple Data) allows the CPU to perform
the same operation on multiple values at once, making vector operations much faster.
Types like float, double, int, and long typically support SIMD acceleration.</p>
</div>




  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_SupportsGpuAcceleration_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.SupportsGpuAcceleration*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_SupportsGpuAcceleration" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.SupportsGpuAcceleration">
  SupportsGpuAcceleration
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L678"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Indicates whether this numeric type supports GPU-accelerated operations.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public bool SupportsGpuAcceleration { get; }</code></pre>
  </div>





  <h4 class="section">Property Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.boolean">bool</a></dt>
    <dd></dd>
  </dl>




  <h4 class="section" id="AiDotNet_Tensors_NumericOperations_ByteOperations_SupportsGpuAcceleration_remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p><b>For Beginners:</b> GPU acceleration uses the graphics card to perform many calculations
in parallel, which can be orders of magnitude faster for large datasets.
Types like float, double, int, and long are typically supported on GPUs.</p>
</div>




  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_Zero_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Zero*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_Zero" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Zero">
  Zero
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L161"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Gets the byte representation of zero.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public byte Zero { get; }</code></pre>
  </div>





  <h4 class="section">Property Value</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The value 0 as a byte.</p>
</dd>
  </dl>




  <h4 class="section" id="AiDotNet_Tensors_NumericOperations_ByteOperations_Zero_remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>
This property returns the byte representation of the value zero, which is simply 0.
It is often used as a neutral element for addition.
</p>
<p><b>For Beginners:</b> This property provides the value zero as a byte.
<p>Zero is a special value in mathematics:</p>
<ul>
<li>Adding zero to any number gives the same number</li>
<li>It's used as a starting point in many algorithms</li>
</ul>
<p>This property gives you a zero that matches the byte type.</p>

</div>




  <h2 class="section" id="methods">Methods
</h2>


  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_Abs_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Abs*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_Abs_System_Byte_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Abs(System.Byte)">
  Abs(byte)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L295"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Returns the absolute value of a byte.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public byte Abs(byte value)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>value</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The byte value.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The input value (since bytes are always non-negative).</p>
</dd>
  </dl>







  <h4 class="section" id="AiDotNet_Tensors_NumericOperations_ByteOperations_Abs_System_Byte__remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>
Since bytes are unsigned and can only hold positive values, this method simply returns the input value.
</p>
<p><b>For Beginners:</b> This method provides the absolute (positive) value of a number.
<p>For regular numbers:</p>
<ul>
<li>The absolute value of 5 is 5</li>
<li>The absolute value of -5 is 5</li>
</ul>
<p>For bytes, which can't be negative, this simply returns the same value.
This method exists to maintain compatibility with other numeric types.</p>

</div>




  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_Abs_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Abs*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_Abs_System_ReadOnlySpan_System_Byte__System_Span_System_Byte__" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Abs(System.ReadOnlySpan{System.Byte},System.Span{System.Byte})">
  Abs(ReadOnlySpan&lt;byte&gt;, Span&lt;byte&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L786"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Computes the absolute value of each element: destination[i] = |x[i]|.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void Abs(ReadOnlySpan&lt;byte&gt; x, Span&lt;byte&gt; destination)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>x</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.readonlyspan-1">ReadOnlySpan</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd><p>The source span.</p>
</dd>
    <dt><code>destination</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.span-1">Span</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd><p>The destination span for results.</p>
</dd>
  </dl>












  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_Add_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Add*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_Add_System_Byte_System_Byte_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Add(System.Byte,System.Byte)">
  Add(byte, byte)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L53"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Adds two byte values together.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public byte Add(byte a, byte b)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>a</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The first value.</p>
</dd>
    <dt><code>b</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The second value.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The sum of the two values, casted to a byte.</p>
</dd>
  </dl>







  <h4 class="section" id="AiDotNet_Tensors_NumericOperations_ByteOperations_Add_System_Byte_System_Byte__remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>
If the sum exceeds the maximum value of a byte (255), the result will wrap around.
For example, 200 + 100 = 44 (as a byte) because 300 exceeds 255 and wraps around.
</p>
<p><b>For Beginners:</b> This method adds two byte numbers together.
<p>Because bytes can only hold values up to 255:</p>
<ul>
<li>Normal additions like 5 + 10 = 15 work as expected</li>
<li>But 250 + 10 = 4 (not 260) because it exceeds 255 and wraps around</li>
</ul>
<p>This wrapping behavior is important to understand when working with bytes.</p>

</div>




  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_Add_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Add*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_Add_System_ReadOnlySpan_System_Byte__System_ReadOnlySpan_System_Byte__System_Span_System_Byte__" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Add(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Span{System.Byte})">
  Add(ReadOnlySpan&lt;byte&gt;, ReadOnlySpan&lt;byte&gt;, Span&lt;byte&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L685"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Performs element-wise addition using SIMD-optimized operations via TensorPrimitivesCore.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void Add(ReadOnlySpan&lt;byte&gt; x, ReadOnlySpan&lt;byte&gt; y, Span&lt;byte&gt; destination)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>x</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.readonlyspan-1">ReadOnlySpan</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd></dd>
    <dt><code>y</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.readonlyspan-1">ReadOnlySpan</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd></dd>
    <dt><code>destination</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.span-1">Span</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd></dd>
  </dl>












  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_AddScalar_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.AddScalar*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_AddScalar_System_ReadOnlySpan_System_Byte__System_Byte_System_Span_System_Byte__" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.AddScalar(System.ReadOnlySpan{System.Byte},System.Byte,System.Span{System.Byte})">
  AddScalar(ReadOnlySpan&lt;byte&gt;, byte, Span&lt;byte&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L783"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Adds a scalar to each element: destination[i] = x[i] + scalar.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void AddScalar(ReadOnlySpan&lt;byte&gt; x, byte scalar, Span&lt;byte&gt; destination)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>x</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.readonlyspan-1">ReadOnlySpan</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd><p>The source span.</p>
</dd>
    <dt><code>scalar</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The scalar value to add.</p>
</dd>
    <dt><code>destination</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.span-1">Span</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd><p>The destination span for results.</p>
</dd>
  </dl>












  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_Ceiling_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Ceiling*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_Ceiling_System_Byte_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Ceiling(System.Byte)">
  Ceiling(byte)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L505"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Returns the smallest integral value greater than or equal to the specified value.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public byte Ceiling(byte value)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>value</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The value to ceiling.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The smallest integral value greater than or equal to value.</p>
</dd>
  </dl>







  <h4 class="section" id="AiDotNet_Tensors_NumericOperations_ByteOperations_Ceiling_System_Byte__remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p><b>For Beginners:</b> Ceiling rounds a number up to the nearest whole number.
For example, Ceiling(3.2) = 4 and Ceiling(-2.7) = -2.
Note that for negative numbers, ceiling rounds toward zero.</p>
</div>




  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_Ceiling_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Ceiling*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_Ceiling_System_ReadOnlySpan_System_Byte__System_Span_System_Byte__" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Ceiling(System.ReadOnlySpan{System.Byte},System.Span{System.Byte})">
  Ceiling(ReadOnlySpan&lt;byte&gt;, Span&lt;byte&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L795"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Computes the ceiling of each element: destination[i] = ceiling(x[i]).</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void Ceiling(ReadOnlySpan&lt;byte&gt; x, Span&lt;byte&gt; destination)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>x</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.readonlyspan-1">ReadOnlySpan</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd><p>The source span.</p>
</dd>
    <dt><code>destination</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.span-1">Span</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd><p>The destination span for results.</p>
</dd>
  </dl>








  <h4 class="section" id="AiDotNet_Tensors_NumericOperations_ByteOperations_Ceiling_System_ReadOnlySpan_System_Byte__System_Span_System_Byte___remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>
<b>For Beginners:</b> Ceiling returns the smallest integer greater than or equal to each value.
For example, ceiling(3.2) = 4, ceiling(-2.7) = -2.
</p>
</div>




  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_Clip_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Clip*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_Clip_System_ReadOnlySpan_System_Byte__System_Byte_System_Byte_System_Span_System_Byte__" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Clip(System.ReadOnlySpan{System.Byte},System.Byte,System.Byte,System.Span{System.Byte})">
  Clip(ReadOnlySpan&lt;byte&gt;, byte, byte, Span&lt;byte&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L788"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Clips (clamps) each element to a range: destination[i] = clamp(x[i], min, max).</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void Clip(ReadOnlySpan&lt;byte&gt; x, byte min, byte max, Span&lt;byte&gt; destination)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>x</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.readonlyspan-1">ReadOnlySpan</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd><p>The source span.</p>
</dd>
    <dt><code>min</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The minimum value.</p>
</dd>
    <dt><code>max</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The maximum value.</p>
</dd>
    <dt><code>destination</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.span-1">Span</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd><p>The destination span for results.</p>
</dd>
  </dl>












  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_Compare_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Compare*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_Compare_System_Byte_System_Byte_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Compare(System.Byte,System.Byte)">
  Compare(byte, byte)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L366"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Compares two values and returns an integer that indicates their relative order.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public int Compare(byte a, byte b)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>a</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The first value to compare.</p>
</dd>
    <dt><code>b</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The second value to compare.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd><p>A value less than zero if a is less than b;
zero if a equals b;
a value greater than zero if a is greater than b.</p>
</dd>
  </dl>







  <h4 class="section" id="AiDotNet_Tensors_NumericOperations_ByteOperations_Compare_System_Byte_System_Byte__remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p><b>For Beginners:</b> This is like comparing two numbers to determine their ordering:</p>
<ul>
<li>If a is less than b, returns a negative number (-1)</li>
<li>If a equals b, returns zero (0)</li>
<li>If a is greater than b, returns a positive number (1)</li>
</ul>
<p>This is commonly used for sorting or determining relative positions of values.</p>
</div>




  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_Copy_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Copy*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_Copy_System_ReadOnlySpan_System_Byte__System_Span_System_Byte__" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Copy(System.ReadOnlySpan{System.Byte},System.Span{System.Byte})">
  Copy(ReadOnlySpan&lt;byte&gt;, Span&lt;byte&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L790"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Copies elements from source to destination.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void Copy(ReadOnlySpan&lt;byte&gt; source, Span&lt;byte&gt; destination)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>source</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.readonlyspan-1">ReadOnlySpan</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd><p>The source span.</p>
</dd>
    <dt><code>destination</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.span-1">Span</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd><p>The destination span.</p>
</dd>
  </dl>












  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_Cos_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Cos*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_Cos_System_Byte_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Cos(System.Byte)">
  Cos(byte)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L519"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Returns the cosine of the specified value (truncated to integer).</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public byte Cos(byte value)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>value</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd></dd>
  </dl>








  <h4 class="section">Exceptions</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.notsupportedexception">NotSupportedException</a></dt>
    <dd><p>Trigonometric operations are not supported for byte type.</p>
</dd>
  </dl>



  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_Cos_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Cos*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_Cos_System_ReadOnlySpan_System_Byte__System_Span_System_Byte__" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Cos(System.ReadOnlySpan{System.Byte},System.Span{System.Byte})">
  Cos(ReadOnlySpan&lt;byte&gt;, Span&lt;byte&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L800"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Computes the cosine of each element: destination[i] = cos(x[i]).</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void Cos(ReadOnlySpan&lt;byte&gt; x, Span&lt;byte&gt; destination)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>x</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.readonlyspan-1">ReadOnlySpan</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd><p>The source span (values in radians).</p>
</dd>
    <dt><code>destination</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.span-1">Span</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd><p>The destination span for results.</p>
</dd>
  </dl>








  <h4 class="section" id="AiDotNet_Tensors_NumericOperations_ByteOperations_Cos_System_ReadOnlySpan_System_Byte__System_Span_System_Byte___remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>
<b>For Beginners:</b> Cosine is a trigonometric function that maps angles to values between -1 and 1.
Input values should be in radians. Used in positional encoding, spherical harmonics, and signal processing.
</p>
</div>




  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_CosineSimilarity_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.CosineSimilarity*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_CosineSimilarity_System_ReadOnlySpan_System_Byte__System_ReadOnlySpan_System_Byte__" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.CosineSimilarity(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})">
  CosineSimilarity(ReadOnlySpan&lt;byte&gt;, ReadOnlySpan&lt;byte&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L775"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Computes cosine similarity using sequential loops.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public byte CosineSimilarity(ReadOnlySpan&lt;byte&gt; x, ReadOnlySpan&lt;byte&gt; y)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>x</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.readonlyspan-1">ReadOnlySpan</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd></dd>
    <dt><code>y</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.readonlyspan-1">ReadOnlySpan</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd></dd>
  </dl>











  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_Divide_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Divide*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_Divide_System_Byte_System_Byte_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Divide(System.Byte,System.Byte)">
  Divide(byte, byte)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L120"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Divides the first byte value by the second.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public byte Divide(byte a, byte b)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>a</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The dividend (value being divided).</p>
</dd>
    <dt><code>b</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The divisor (value to divide by).</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The quotient of the division, casted to a byte.</p>
</dd>
  </dl>







  <h4 class="section" id="AiDotNet_Tensors_NumericOperations_ByteOperations_Divide_System_Byte_System_Byte__remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>
This performs integer division, so any fractional part of the result is truncated.
For example, 5 / 2 = 2 (not 2.5). Division by zero will throw an exception.
</p>
<p><b>For Beginners:</b> This method divides one byte by another.
<p>Important things to know:</p>
<ul>
<li>This is integer division, so 5 / 2 = 2 (the decimal part is dropped)</li>
<li>Dividing by zero will cause an error</li>
<li>The result always fits within the byte range</li>
</ul>
<p>This works like division with whole numbers in elementary math.</p>

</div>




  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_Divide_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Divide*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_Divide_System_ReadOnlySpan_System_Byte__System_ReadOnlySpan_System_Byte__System_Span_System_Byte__" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Divide(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Span{System.Byte})">
  Divide(ReadOnlySpan&lt;byte&gt;, ReadOnlySpan&lt;byte&gt;, Span&lt;byte&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L703"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Performs element-wise division using SIMD-optimized operations via TensorPrimitivesCore.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void Divide(ReadOnlySpan&lt;byte&gt; x, ReadOnlySpan&lt;byte&gt; y, Span&lt;byte&gt; destination)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>x</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.readonlyspan-1">ReadOnlySpan</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd></dd>
    <dt><code>y</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.readonlyspan-1">ReadOnlySpan</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd></dd>
    <dt><code>destination</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.span-1">Span</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd></dd>
  </dl>












  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_DivideScalar_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.DivideScalar*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_DivideScalar_System_ReadOnlySpan_System_Byte__System_Byte_System_Span_System_Byte__" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.DivideScalar(System.ReadOnlySpan{System.Byte},System.Byte,System.Span{System.Byte})">
  DivideScalar(ReadOnlySpan&lt;byte&gt;, byte, Span&lt;byte&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L782"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Divides each element by a scalar: destination[i] = x[i] / scalar.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void DivideScalar(ReadOnlySpan&lt;byte&gt; x, byte scalar, Span&lt;byte&gt; destination)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>x</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.readonlyspan-1">ReadOnlySpan</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd><p>The source span.</p>
</dd>
    <dt><code>scalar</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The scalar value to divide by.</p>
</dd>
    <dt><code>destination</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.span-1">Span</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd><p>The destination span for results.</p>
</dd>
  </dl>












  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_Dot_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Dot*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_Dot_System_ReadOnlySpan_System_Byte__System_ReadOnlySpan_System_Byte__" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Dot(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})">
  Dot(ReadOnlySpan&lt;byte&gt;, ReadOnlySpan&lt;byte&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L709"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Computes dot product using sequential loops.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public byte Dot(ReadOnlySpan&lt;byte&gt; x, ReadOnlySpan&lt;byte&gt; y)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>x</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.readonlyspan-1">ReadOnlySpan</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd></dd>
    <dt><code>y</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.readonlyspan-1">ReadOnlySpan</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd></dd>
  </dl>











  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_ELU_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.ELU*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_ELU_System_ReadOnlySpan_System_Byte__System_Byte_System_Span_System_Byte__" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.ELU(System.ReadOnlySpan{System.Byte},System.Byte,System.Span{System.Byte})">
  ELU(ReadOnlySpan&lt;byte&gt;, byte, Span&lt;byte&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L831"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Computes ELU (Exponential Linear Unit) element-wise: x if x &gt; 0, alpha * (exp(x) - 1) otherwise.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void ELU(ReadOnlySpan&lt;byte&gt; x, byte alpha, Span&lt;byte&gt; destination)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>x</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.readonlyspan-1">ReadOnlySpan</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd><p>The source span.</p>
</dd>
    <dt><code>alpha</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The scale factor for negative values (typically 1.0).</p>
</dd>
    <dt><code>destination</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.span-1">Span</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd><p>The destination span for results.</p>
</dd>
  </dl>








  <h4 class="section" id="AiDotNet_Tensors_NumericOperations_ByteOperations_ELU_System_ReadOnlySpan_System_Byte__System_Byte_System_Span_System_Byte___remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>
<b>For Beginners:</b> ELU is similar to ReLU for positive inputs but produces smooth
negative values for negative inputs. This helps push mean activations closer to zero,
speeding up learning.
</p>
<p>
<b>Performance:</b> Uses SIMD-optimized exp, comparisons, and conditional selection
for 2-4x speedup over scalar implementation.
</p>
</div>




  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_Equals_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Equals*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_Equals_System_Byte_System_Byte_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Equals(System.Byte,System.Byte)">
  Equals(byte, byte)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L364"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Determines whether two byte values are equal.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public bool Equals(byte a, byte b)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>a</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The first value to compare.</p>
</dd>
    <dt><code>b</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The second value to compare.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.boolean">bool</a></dt>
    <dd><p>true if the values are equal; otherwise, false.</p>
</dd>
  </dl>







  <h4 class="section" id="AiDotNet_Tensors_NumericOperations_ByteOperations_Equals_System_Byte_System_Byte__remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>
This method compares two byte values and returns true if they are equal.
</p>
<p><b>For Beginners:</b> This method checks if two numbers have exactly the same value.
<p>For example:</p>
<ul>
<li>5 equals 5 returns true</li>
<li>10 equals 5 returns false</li>
</ul>
<p>This is a basic comparison operation used in many algorithms.</p>

</div>




  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_Exp_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Exp*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_Exp_System_Byte_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Exp(System.Byte)">
  Exp(byte)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L343"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Calculates e raised to the specified power.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public byte Exp(byte value)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>value</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The power to raise e to.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>e raised to the specified power, casted to a byte.</p>
</dd>
  </dl>







  <h4 class="section" id="AiDotNet_Tensors_NumericOperations_ByteOperations_Exp_System_Byte__remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>
This method calculates the exponential function (e^value) and rounds the result to the nearest integer.
If the result exceeds 255, it is capped at 255.
</p>
<p><b>For Beginners:</b> This method calculates the mathematical constant e (2.718) raised to a power.
<p>For example:</p>
<ul>
<li>e^1  2.718 (rounded to 3 as a byte)</li>
<li>e^2  7.389 (rounded to 7 as a byte)</li>
<li>e^5  148.413 (rounded to 148 as a byte)</li>
</ul>
<p>The result is limited to 255 (maximum byte value).
This function grows very quickly, so even moderate input values will reach the maximum.</p>

</div>




  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_Exp_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Exp*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_Exp_System_ReadOnlySpan_System_Byte__System_Span_System_Byte__" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Exp(System.ReadOnlySpan{System.Byte},System.Span{System.Byte})">
  Exp(ReadOnlySpan&lt;byte&gt;, Span&lt;byte&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L734"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Transcendental operations are not supported for byte type.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void Exp(ReadOnlySpan&lt;byte&gt; x, Span&lt;byte&gt; destination)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>x</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.readonlyspan-1">ReadOnlySpan</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd></dd>
    <dt><code>destination</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.span-1">Span</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd></dd>
  </dl>









  <h4 class="section">Exceptions</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.notsupportedexception">NotSupportedException</a></dt>
    <dd><p>Always thrown. Exp produces misleading results for bytes (range 0-255).</p>
</dd>
  </dl>



  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_Fill_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Fill*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_Fill_System_Span_System_Byte__System_Byte_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Fill(System.Span{System.Byte},System.Byte)">
  Fill(Span&lt;byte&gt;, byte)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L780"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Fills the destination span with a constant value.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void Fill(Span&lt;byte&gt; destination, byte value)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>destination</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.span-1">Span</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd><p>The destination span to fill.</p>
</dd>
    <dt><code>value</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The value to fill with.</p>
</dd>
  </dl>












  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_Floor_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Floor*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_Floor_System_Byte_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Floor(System.Byte)">
  Floor(byte)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L504"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Returns the largest integral value less than or equal to the specified value.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public byte Floor(byte value)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>value</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The value to floor.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The largest integral value less than or equal to value.</p>
</dd>
  </dl>







  <h4 class="section" id="AiDotNet_Tensors_NumericOperations_ByteOperations_Floor_System_Byte__remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p><b>For Beginners:</b> Floor rounds a number down to the nearest whole number.
For example, Floor(3.7) = 3 and Floor(-2.3) = -3.
Note that for negative numbers, floor rounds away from zero.</p>
</div>




  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_Floor_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Floor*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_Floor_System_ReadOnlySpan_System_Byte__System_Span_System_Byte__" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Floor(System.ReadOnlySpan{System.Byte},System.Span{System.Byte})">
  Floor(ReadOnlySpan&lt;byte&gt;, Span&lt;byte&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L794"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Computes the floor of each element: destination[i] = floor(x[i]).</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void Floor(ReadOnlySpan&lt;byte&gt; x, Span&lt;byte&gt; destination)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>x</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.readonlyspan-1">ReadOnlySpan</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd><p>The source span.</p>
</dd>
    <dt><code>destination</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.span-1">Span</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd><p>The destination span for results.</p>
</dd>
  </dl>








  <h4 class="section" id="AiDotNet_Tensors_NumericOperations_ByteOperations_Floor_System_ReadOnlySpan_System_Byte__System_Span_System_Byte___remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>
<b>For Beginners:</b> Floor returns the largest integer less than or equal to each value.
For example, floor(3.7) = 3, floor(-2.3) = -3.
</p>
</div>




  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_Frac_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Frac*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_Frac_System_Byte_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Frac(System.Byte)">
  Frac(byte)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L506"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Returns the fractional part of the specified value (value - floor(value)).</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public byte Frac(byte value)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>value</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The value to get the fractional part of.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The fractional part of the value.</p>
</dd>
  </dl>







  <h4 class="section" id="AiDotNet_Tensors_NumericOperations_ByteOperations_Frac_System_Byte__remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p><b>For Beginners:</b> The fractional part is the portion after the decimal point.
For example, Frac(3.7) = 0.7. Note that Frac(-2.3) = 0.7 (not -0.3),
since frac is defined as x - floor(x).
This is useful in hash encoding and periodic functions.</p>
</div>




  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_Frac_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Frac*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_Frac_System_ReadOnlySpan_System_Byte__System_Span_System_Byte__" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Frac(System.ReadOnlySpan{System.Byte},System.Span{System.Byte})">
  Frac(ReadOnlySpan&lt;byte&gt;, Span&lt;byte&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L796"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Computes the fractional part of each element: destination[i] = x[i] - floor(x[i]).</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void Frac(ReadOnlySpan&lt;byte&gt; x, Span&lt;byte&gt; destination)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>x</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.readonlyspan-1">ReadOnlySpan</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd><p>The source span.</p>
</dd>
    <dt><code>destination</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.span-1">Span</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd><p>The destination span for results.</p>
</dd>
  </dl>








  <h4 class="section" id="AiDotNet_Tensors_NumericOperations_ByteOperations_Frac_System_ReadOnlySpan_System_Byte__System_Span_System_Byte___remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>
<b>For Beginners:</b> The fractional part is the portion after the decimal point.
For example, frac(3.7) = 0.7, frac(-2.3) = 0.7 (not -0.3, since frac = x - floor(x)).
This is useful in hash encoding and periodic functions.
</p>
</div>




  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_FromDouble_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.FromDouble*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_FromDouble_System_Double_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.FromDouble(System.Double)">
  FromDouble(double)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L228"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Converts a double value to a byte.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public byte FromDouble(double value)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>value</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.double">double</a></dt>
    <dd><p>The double value to convert.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The double value converted to a byte.</p>
</dd>
  </dl>







  <h4 class="section" id="AiDotNet_Tensors_NumericOperations_ByteOperations_FromDouble_System_Double__remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>
This method casts a double value to a byte. If the value is outside the range of a byte (0-255),
it will be truncated. Fractional parts are also truncated.
</p>
<p><b>For Beginners:</b> This method converts a decimal number to a byte.
<p>When converting:</p>
<ul>
<li>The decimal part is dropped (3.7 becomes 3)</li>
<li>Values below 0 become 0</li>
<li>Values above 255 become a wrapped value (usually unexpected)</li>
</ul>
<p>For example, 300.5 would become 44 as a byte (300 - 256 = 44).</p>

</div>




  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_FromFloat_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.FromFloat*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_FromFloat_System_Single_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.FromFloat(System.Single)">
  FromFloat(float)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L648"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Converts a float value to byte.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public byte FromFloat(float value)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>value</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.single">float</a></dt>
    <dd><p>The float value to convert.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The value as a byte.</p>
</dd>
  </dl>







  <h4 class="section" id="AiDotNet_Tensors_NumericOperations_ByteOperations_FromFloat_System_Single__remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>This conversion will round the float to the nearest integer and clamp it to the byte range [0, 255].</p>
</div>




  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_FromFloatSpan_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.FromFloatSpan*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_FromFloatSpan_System_ReadOnlySpan_System_Single__System_Span_System_Byte__" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.FromFloatSpan(System.ReadOnlySpan{System.Single},System.Span{System.Byte})">
  FromFloatSpan(ReadOnlySpan&lt;float&gt;, Span&lt;byte&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L810"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Converts elements from float (FP32) to type T: destination[i] = (T)source[i].</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void FromFloatSpan(ReadOnlySpan&lt;float&gt; source, Span&lt;byte&gt; destination)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>source</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.readonlyspan-1">ReadOnlySpan</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.single">float</a>&gt;</dt>
    <dd><p>The source span containing float values.</p>
</dd>
    <dt><code>destination</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.span-1">Span</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd><p>The destination span for values of type T.</p>
</dd>
  </dl>








  <h4 class="section" id="AiDotNet_Tensors_NumericOperations_ByteOperations_FromFloatSpan_System_ReadOnlySpan_System_Single__System_Span_System_Byte___remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>
<b>For Beginners:</b> This method converts an array of 32-bit floating-point numbers back to
another type (like double or int). This is commonly used when retrieving results from GPU
processing and converting them back to the user's preferred type.
</p>
<p>
<b>Performance:</b> This operation can be SIMD-accelerated on .NET 8+, providing significant
speedup over sequential conversion loops.
</p>
</div>




  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_FromHalf_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.FromHalf*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_FromHalf_System_Half_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.FromHalf(System.Half)">
  FromHalf(Half)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L665"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Converts a Half value to byte.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public byte FromHalf(Half value)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>value</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.half">Half</a></dt>
    <dd><p>The Half value to convert.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The value as a byte.</p>
</dd>
  </dl>







  <h4 class="section" id="AiDotNet_Tensors_NumericOperations_ByteOperations_FromHalf_System_Half__remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>This conversion will round the Half to the nearest integer and clamp it to the byte range [0, 255].</p>
</div>




  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_FromHalfSpan_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.FromHalfSpan*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_FromHalfSpan_System_ReadOnlySpan_System_Half__System_Span_System_Byte__" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.FromHalfSpan(System.ReadOnlySpan{System.Half},System.Span{System.Byte})">
  FromHalfSpan(ReadOnlySpan&lt;Half&gt;, Span&lt;byte&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L816"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Converts elements from Half (FP16) to type T: destination[i] = (T)source[i].</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void FromHalfSpan(ReadOnlySpan&lt;Half&gt; source, Span&lt;byte&gt; destination)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>source</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.readonlyspan-1">ReadOnlySpan</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.half">Half</a>&gt;</dt>
    <dd><p>The source span containing Half values.</p>
</dd>
    <dt><code>destination</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.span-1">Span</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd><p>The destination span for values of type T.</p>
</dd>
  </dl>








  <h4 class="section" id="AiDotNet_Tensors_NumericOperations_ByteOperations_FromHalfSpan_System_ReadOnlySpan_System_Half__System_Span_System_Byte___remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>
<b>For Beginners:</b> This method converts an array of 16-bit half-precision floating-point
numbers to another type (like float or double). This is commonly used when retrieving results
from GPU processing that used half precision.
</p>
<p>
<b>Performance:</b> This operation can be SIMD-accelerated on .NET 8+, providing significant
speedup over sequential conversion loops.
</p>
</div>




  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_GELU_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.GELU*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_GELU_System_ReadOnlySpan_System_Byte__System_Span_System_Byte__" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.GELU(System.ReadOnlySpan{System.Byte},System.Span{System.Byte})">
  GELU(ReadOnlySpan&lt;byte&gt;, Span&lt;byte&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L822"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Computes GELU (Gaussian Error Linear Unit) element-wise.
Uses approximation: 0.5 * x * (1 + tanh(sqrt(2/pi) * (x + 0.044715 * x^3)))</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void GELU(ReadOnlySpan&lt;byte&gt; x, Span&lt;byte&gt; destination)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>x</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.readonlyspan-1">ReadOnlySpan</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd><p>The source span.</p>
</dd>
    <dt><code>destination</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.span-1">Span</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd><p>The destination span for results.</p>
</dd>
  </dl>








  <h4 class="section" id="AiDotNet_Tensors_NumericOperations_ByteOperations_GELU_System_ReadOnlySpan_System_Byte__System_Span_System_Byte___remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>
<b>For Beginners:</b> GELU is a smooth activation function that approximates
multiplying the input by a probability based on its value. It's used in
Transformers (BERT, GPT) and provides smooth gradients for optimization.
</p>
<p>
<b>Performance:</b> Uses SIMD-optimized tanh, exp, and arithmetic operations
for 2-4x speedup over scalar implementation.
</p>
</div>




  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_GreaterThan_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.GreaterThan*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_GreaterThan_System_Byte_System_Byte_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.GreaterThan(System.Byte,System.Byte)">
  GreaterThan(byte, byte)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L251"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Determines whether the first byte value is greater than the second.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public bool GreaterThan(byte a, byte b)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>a</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The first value to compare.</p>
</dd>
    <dt><code>b</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The second value to compare.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.boolean">bool</a></dt>
    <dd><p>true if the first value is greater than the second; otherwise, false.</p>
</dd>
  </dl>







  <h4 class="section" id="AiDotNet_Tensors_NumericOperations_ByteOperations_GreaterThan_System_Byte_System_Byte__remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>
This method compares two byte values and returns true if the first is greater than the second.
Since bytes are unsigned, the comparison is straightforward.
</p>
<p><b>For Beginners:</b> This method checks if the first number is larger than the second.
<p>For example:</p>
<ul>
<li>10 &gt; 5 returns true</li>
<li>5 &gt; 10 returns false</li>
<li>5 &gt; 5 returns false</li>
</ul>
<p>This is a simple comparison operation used in many algorithms.</p>

</div>




  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_GreaterThanOrEquals_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.GreaterThanOrEquals*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_GreaterThanOrEquals_System_Byte_System_Byte_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.GreaterThanOrEquals(System.Byte,System.Byte)">
  GreaterThanOrEquals(byte, byte)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L441"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Determines whether the first byte value is greater than or equal to the second.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public bool GreaterThanOrEquals(byte a, byte b)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>a</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The first value to compare.</p>
</dd>
    <dt><code>b</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The second value to compare.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.boolean">bool</a></dt>
    <dd><p>true if the first value is greater than or equal to the second; otherwise, false.</p>
</dd>
  </dl>







  <h4 class="section" id="AiDotNet_Tensors_NumericOperations_ByteOperations_GreaterThanOrEquals_System_Byte_System_Byte__remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>
This method compares two byte values and returns true if the first is greater than or equal to the second.
</p>
<p><b>For Beginners:</b> This method checks if the first number is larger than or the same as the second.
<p>For example:</p>
<ul>
<li>10 &gt;= 5 returns true</li>
<li>5 &gt;= 10 returns false</li>
<li>5 &gt;= 5 returns true</li>
</ul>
<p>This is a simple comparison operation used in many algorithms.</p>

</div>




  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_IsInfinity_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.IsInfinity*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_IsInfinity_System_Byte_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.IsInfinity(System.Byte)">
  IsInfinity(byte)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L595"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Determines whether the specified byte value is infinity.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public bool IsInfinity(byte value)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>value</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The byte value to check.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.boolean">bool</a></dt>
    <dd><p>Always returns false, as byte values cannot represent infinity.</p>
</dd>
  </dl>







  <h4 class="section" id="AiDotNet_Tensors_NumericOperations_ByteOperations_IsInfinity_System_Byte__remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>
Bytes cannot represent special values like infinity, so this method always returns false.
</p>
<p><b>For Beginners:</b> This method checks if a value is infinity.
<p>For floating-point types like float or double, certain operations can result in infinity.
However, bytes cannot represent infinity, so this method always returns false.</p>
<p>This method exists to maintain compatibility with other numeric types.</p>

</div>




  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_IsNaN_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.IsNaN*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_IsNaN_System_Byte_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.IsNaN(System.Byte)">
  IsNaN(byte)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L576"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Determines whether the specified byte value is NaN (Not a Number).</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public bool IsNaN(byte value)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>value</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The byte value to check.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.boolean">bool</a></dt>
    <dd><p>Always returns false, as byte values cannot represent NaN.</p>
</dd>
  </dl>







  <h4 class="section" id="AiDotNet_Tensors_NumericOperations_ByteOperations_IsNaN_System_Byte__remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>
Bytes cannot represent special values like NaN, so this method always returns false.
</p>
<p><b>For Beginners:</b> This method checks if a value is "Not a Number" (NaN).
<p>For floating-point types like float or double, certain operations can result in NaN.
However, bytes cannot represent NaN, so this method always returns false.</p>
<p>This method exists to maintain compatibility with other numeric types.</p>

</div>




  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_LeakyReLU_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.LeakyReLU*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_LeakyReLU_System_ReadOnlySpan_System_Byte__System_Byte_System_Span_System_Byte__" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.LeakyReLU(System.ReadOnlySpan{System.Byte},System.Byte,System.Span{System.Byte})">
  LeakyReLU(ReadOnlySpan&lt;byte&gt;, byte, Span&lt;byte&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L819"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Computes LeakyReLU element-wise: destination[i] = x[i] &gt; 0 ? x[i] : alpha * x[i].</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void LeakyReLU(ReadOnlySpan&lt;byte&gt; x, byte alpha, Span&lt;byte&gt; destination)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>x</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.readonlyspan-1">ReadOnlySpan</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd><p>The source span.</p>
</dd>
    <dt><code>alpha</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The negative slope coefficient (typically 0.01).</p>
</dd>
    <dt><code>destination</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.span-1">Span</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd><p>The destination span for results.</p>
</dd>
  </dl>








  <h4 class="section" id="AiDotNet_Tensors_NumericOperations_ByteOperations_LeakyReLU_System_ReadOnlySpan_System_Byte__System_Byte_System_Span_System_Byte___remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>
<b>For Beginners:</b> LeakyReLU is a variant of ReLU that allows a small negative slope
for negative inputs instead of zeroing them out. This helps prevent "dying neurons".
</p>
<p>
<b>Performance:</b> This operation can be SIMD-accelerated using vectorized comparisons
and conditional selection, providing 3-5x speedup over scalar loops.
</p>
</div>




  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_LessThan_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.LessThan*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_LessThan_System_Byte_System_Byte_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.LessThan(System.Byte,System.Byte)">
  LessThan(byte, byte)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L274"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"></div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public bool LessThan(byte a, byte b)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>a</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd></dd>
    <dt><code>b</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.boolean">bool</a></dt>
    <dd></dd>
  </dl>











  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_LessThanOrEquals_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.LessThanOrEquals*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_LessThanOrEquals_System_Byte_System_Byte_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.LessThanOrEquals(System.Byte,System.Byte)">
  LessThanOrEquals(byte, byte)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L463"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"></div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public bool LessThanOrEquals(byte a, byte b)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>a</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd></dd>
    <dt><code>b</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.boolean">bool</a></dt>
    <dd></dd>
  </dl>











  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_Log_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Log*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_Log_System_Byte_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Log(System.Byte)">
  Log(byte)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L419"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Calculates the natural logarithm of a byte value.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public byte Log(byte value)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>value</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The value to calculate the natural logarithm of.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The natural logarithm of the specified value, casted to a byte.</p>
</dd>
  </dl>







  <h4 class="section" id="AiDotNet_Tensors_NumericOperations_ByteOperations_Log_System_Byte__remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>
This method calculates the natural logarithm (base e) of the specified value.
The result is cast to a byte, so any fractional part is truncated. Log of 0 will result in an exception.
</p>
<p><b>For Beginners:</b> This method calculates the natural logarithm of a number.
<p>The natural logarithm answers the question: &quot;To what power must e be raised to get this number?&quot;</p>
<p>For example:</p>
<ul>
<li>Log of 1 is 0 (e^0 = 1)</li>
<li>Log of 3 is approximately 1.099 (truncated to 1 as a byte)</li>
<li>Log of 7 is approximately 1.946 (truncated to 1 as a byte)</li>
</ul>
<p>Important notes:</p>
<ul>
<li>Log of 0 causes an error</li>
<li>Most logarithm results will be very small as bytes</li>
<li>The decimal part is removed when converting to byte</li>
</ul>

</div>




  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_Log_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Log*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_Log_System_ReadOnlySpan_System_Byte__System_Span_System_Byte__" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Log(System.ReadOnlySpan{System.Byte},System.Span{System.Byte})">
  Log(ReadOnlySpan&lt;byte&gt;, Span&lt;byte&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L741"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Transcendental operations are not supported for byte type.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void Log(ReadOnlySpan&lt;byte&gt; x, Span&lt;byte&gt; destination)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>x</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.readonlyspan-1">ReadOnlySpan</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd></dd>
    <dt><code>destination</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.span-1">Span</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd></dd>
  </dl>









  <h4 class="section">Exceptions</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.notsupportedexception">NotSupportedException</a></dt>
    <dd><p>Always thrown. Log produces misleading results for bytes (only 0-7 possible).</p>
</dd>
  </dl>



  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_Log2_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Log2*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_Log2_System_ReadOnlySpan_System_Byte__System_Span_System_Byte__" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Log2(System.ReadOnlySpan{System.Byte},System.Span{System.Byte})">
  Log2(ReadOnlySpan&lt;byte&gt;, Span&lt;byte&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L762"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Transcendental operations are not supported for byte type.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void Log2(ReadOnlySpan&lt;byte&gt; x, Span&lt;byte&gt; destination)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>x</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.readonlyspan-1">ReadOnlySpan</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd></dd>
    <dt><code>destination</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.span-1">Span</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd></dd>
  </dl>









  <h4 class="section">Exceptions</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.notsupportedexception">NotSupportedException</a></dt>
    <dd><p>Always thrown. Log2 produces only 0-7 for bytes.</p>
</dd>
  </dl>



  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_Max_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Max*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_Max_System_ReadOnlySpan_System_Byte__" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Max(System.ReadOnlySpan{System.Byte})">
  Max(ReadOnlySpan&lt;byte&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L721"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Finds maximum using sequential loops.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public byte Max(ReadOnlySpan&lt;byte&gt; x)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>x</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.readonlyspan-1">ReadOnlySpan</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd></dd>
  </dl>











  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_Min_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Min*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_Min_System_ReadOnlySpan_System_Byte__" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Min(System.ReadOnlySpan{System.Byte})">
  Min(ReadOnlySpan&lt;byte&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L727"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Finds minimum using sequential loops.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public byte Min(ReadOnlySpan&lt;byte&gt; x)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>x</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.readonlyspan-1">ReadOnlySpan</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd></dd>
  </dl>











  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_Mish_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Mish*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_Mish_System_ReadOnlySpan_System_Byte__System_Span_System_Byte__" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Mish(System.ReadOnlySpan{System.Byte},System.Span{System.Byte})">
  Mish(ReadOnlySpan&lt;byte&gt;, Span&lt;byte&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L825"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Computes Mish activation element-wise: x * tanh(softplus(x)) = x * tanh(ln(1 + exp(x))).</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void Mish(ReadOnlySpan&lt;byte&gt; x, Span&lt;byte&gt; destination)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>x</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.readonlyspan-1">ReadOnlySpan</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd><p>The source span.</p>
</dd>
    <dt><code>destination</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.span-1">Span</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd><p>The destination span for results.</p>
</dd>
  </dl>








  <h4 class="section" id="AiDotNet_Tensors_NumericOperations_ByteOperations_Mish_System_ReadOnlySpan_System_Byte__System_Span_System_Byte___remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>
<b>For Beginners:</b> Mish is a smooth, self-regularized activation function that
often outperforms ReLU in practice. It's unbounded above, bounded below, smooth,
and non-monotonic.
</p>
<p>
<b>Performance:</b> Uses SIMD-optimized exp, log, and tanh operations
for 2-3x speedup over scalar implementation.
</p>
</div>




  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_Multiply_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Multiply*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_Multiply_System_Byte_System_Byte_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Multiply(System.Byte,System.Byte)">
  Multiply(byte, byte)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L97"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Multiplies two byte values together.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public byte Multiply(byte a, byte b)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>a</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The first value.</p>
</dd>
    <dt><code>b</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The second value.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The product of the two values, casted to a byte.</p>
</dd>
  </dl>







  <h4 class="section" id="AiDotNet_Tensors_NumericOperations_ByteOperations_Multiply_System_Byte_System_Byte__remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>
If the product exceeds the maximum value of a byte (255), the result will wrap around.
For example, 20 * 20 = 144 (as a byte) because 400 exceeds 255 and wraps around.
</p>
<p><b>For Beginners:</b> This method multiplies two byte numbers together.
<p>Because bytes have a small range:</p>
<ul>
<li>Small multiplications like 2 * 3 = 6 work as expected</li>
<li>But larger ones like 16 * 16 = 0 (not 256) because it wraps around</li>
</ul>
<p>Be careful with multiplication as it's easy to exceed the byte range.</p>

</div>




  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_Multiply_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Multiply*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_Multiply_System_ReadOnlySpan_System_Byte__System_ReadOnlySpan_System_Byte__System_Span_System_Byte__" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Multiply(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Span{System.Byte})">
  Multiply(ReadOnlySpan&lt;byte&gt;, ReadOnlySpan&lt;byte&gt;, Span&lt;byte&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L697"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Performs element-wise multiplication using SIMD-optimized operations via TensorPrimitivesCore.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void Multiply(ReadOnlySpan&lt;byte&gt; x, ReadOnlySpan&lt;byte&gt; y, Span&lt;byte&gt; destination)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>x</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.readonlyspan-1">ReadOnlySpan</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd></dd>
    <dt><code>y</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.readonlyspan-1">ReadOnlySpan</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd></dd>
    <dt><code>destination</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.span-1">Span</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd></dd>
  </dl>












  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_MultiplyAdd_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.MultiplyAdd*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_MultiplyAdd_System_ReadOnlySpan_System_Byte__System_ReadOnlySpan_System_Byte__System_Byte_System_Span_System_Byte__" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.MultiplyAdd(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Byte,System.Span{System.Byte})">
  MultiplyAdd(ReadOnlySpan&lt;byte&gt;, ReadOnlySpan&lt;byte&gt;, byte, Span&lt;byte&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L804"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Computes fused multiply-add: destination[i] = x[i] + y[i] * scalar.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void MultiplyAdd(ReadOnlySpan&lt;byte&gt; x, ReadOnlySpan&lt;byte&gt; y, byte scalar, Span&lt;byte&gt; destination)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>x</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.readonlyspan-1">ReadOnlySpan</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd><p>The first source span (values to add to).</p>
</dd>
    <dt><code>y</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.readonlyspan-1">ReadOnlySpan</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd><p>The second source span (values to multiply).</p>
</dd>
    <dt><code>scalar</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The scalar value to multiply y by.</p>
</dd>
    <dt><code>destination</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.span-1">Span</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd><p>The destination span for results.</p>
</dd>
  </dl>








  <h4 class="section" id="AiDotNet_Tensors_NumericOperations_ByteOperations_MultiplyAdd_System_ReadOnlySpan_System_Byte__System_ReadOnlySpan_System_Byte__System_Byte_System_Span_System_Byte___remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>
<b>For Beginners:</b> This operation multiplies each element of y by a scalar value,
then adds it to the corresponding element of x. It's commonly used in matrix multiplication
and neural network operations.
</p>
<p>
<b>Performance:</b> When FMA (Fused Multiply-Add) hardware is available, this operation
can be performed in a single instruction, providing better performance and precision
than separate multiply and add operations.
</p>
</div>




  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_MultiplyScalar_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.MultiplyScalar*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_MultiplyScalar_System_ReadOnlySpan_System_Byte__System_Byte_System_Span_System_Byte__" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.MultiplyScalar(System.ReadOnlySpan{System.Byte},System.Byte,System.Span{System.Byte})">
  MultiplyScalar(ReadOnlySpan&lt;byte&gt;, byte, Span&lt;byte&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L781"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Multiplies each element by a scalar: destination[i] = x[i] * scalar.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void MultiplyScalar(ReadOnlySpan&lt;byte&gt; x, byte scalar, Span&lt;byte&gt; destination)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>x</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.readonlyspan-1">ReadOnlySpan</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd><p>The source span.</p>
</dd>
    <dt><code>scalar</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The scalar value to multiply by.</p>
</dd>
    <dt><code>destination</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.span-1">Span</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd><p>The destination span for results.</p>
</dd>
  </dl>












  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_Negate_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Negate*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_Negate_System_Byte_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Negate(System.Byte)">
  Negate(byte)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L141"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Negates the specified byte value.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public byte Negate(byte a)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>a</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The value to negate.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The negated value, casted to a byte.</p>
</dd>
  </dl>







  <h4 class="section" id="AiDotNet_Tensors_NumericOperations_ByteOperations_Negate_System_Byte__remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>
Due to the unsigned nature of bytes, negating a byte value results in a wrap-around.
For example, negating 1 results in 255, and negating 10 results in 246.
</p>
<p><b>For Beginners:</b> This method tries to reverse the sign of a byte.
<p>Since bytes can't be negative:</p>
<ul>
<li>Negating 5 gives 251 (not -5) due to wrapping</li>
<li>The formula is: 256 - value (when value &gt; 0)</li>
</ul>
<p>This mainly exists to fulfill the interface requirements and has specialized behavior for bytes.</p>

</div>




  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_Negate_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Negate*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_Negate_System_ReadOnlySpan_System_Byte__System_Span_System_Byte__" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Negate(System.ReadOnlySpan{System.Byte},System.Span{System.Byte})">
  Negate(ReadOnlySpan&lt;byte&gt;, Span&lt;byte&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L787"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Negates each element: destination[i] = -x[i].</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void Negate(ReadOnlySpan&lt;byte&gt; x, Span&lt;byte&gt; destination)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>x</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.readonlyspan-1">ReadOnlySpan</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd><p>The source span.</p>
</dd>
    <dt><code>destination</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.span-1">Span</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd><p>The destination span for results.</p>
</dd>
  </dl>












  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_Pow_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Pow*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_Pow_System_ReadOnlySpan_System_Byte__System_Byte_System_Span_System_Byte__" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Pow(System.ReadOnlySpan{System.Byte},System.Byte,System.Span{System.Byte})">
  Pow(ReadOnlySpan&lt;byte&gt;, byte, Span&lt;byte&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L789"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Computes the power of each element: destination[i] = x[i]^power.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void Pow(ReadOnlySpan&lt;byte&gt; x, byte power, Span&lt;byte&gt; destination)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>x</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.readonlyspan-1">ReadOnlySpan</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd><p>The source span.</p>
</dd>
    <dt><code>power</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The power to raise each element to.</p>
</dd>
    <dt><code>destination</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.span-1">Span</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd><p>The destination span for results.</p>
</dd>
  </dl>












  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_Power_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Power*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_Power_System_Byte_System_Byte_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Power(System.Byte,System.Byte)">
  Power(byte, byte)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L392"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Raises a byte value to the specified power.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public byte Power(byte baseValue, byte exponent)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>baseValue</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The base value.</p>
</dd>
    <dt><code>exponent</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The exponent.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The base value raised to the specified power, casted to a byte.</p>
</dd>
  </dl>







  <h4 class="section" id="AiDotNet_Tensors_NumericOperations_ByteOperations_Power_System_Byte_System_Byte__remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>
This method uses Math.Pow to calculate the power and then casts the result to a byte.
If the result exceeds the maximum value of a byte (255), it will wrap around.
</p>
<p><b>For Beginners:</b> This method raises one number to the power of another.
<p>For example:</p>
<ul>
<li>2 raised to power 3 is 8 (2 = 2  2  2 = 8)</li>
<li>3 raised to power 2 is 9 (3 = 3  3 = 9)</li>
</ul>
<p>Because of byte limits:</p>
<ul>
<li>2 raised to power 8 is 0 (28 = 256, which wraps to 0)</li>
<li>Results above 255 will wrap around</li>
</ul>
<p>Powers grow very quickly, so be cautious with larger values.</p>

</div>




  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_ReLU_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.ReLU*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_ReLU_System_ReadOnlySpan_System_Byte__System_Span_System_Byte__" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.ReLU(System.ReadOnlySpan{System.Byte},System.Span{System.Byte})">
  ReLU(ReadOnlySpan&lt;byte&gt;, Span&lt;byte&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L834"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Computes ReLU (Rectified Linear Unit) element-wise: max(0, x).</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void ReLU(ReadOnlySpan&lt;byte&gt; x, Span&lt;byte&gt; destination)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>x</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.readonlyspan-1">ReadOnlySpan</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd><p>The source span.</p>
</dd>
    <dt><code>destination</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.span-1">Span</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd><p>The destination span for results.</p>
</dd>
  </dl>








  <h4 class="section" id="AiDotNet_Tensors_NumericOperations_ByteOperations_ReLU_System_ReadOnlySpan_System_Byte__System_Span_System_Byte___remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>
<b>For Beginners:</b> ReLU is the most common activation function in deep learning.
It outputs the input directly if positive, otherwise outputs zero.
</p>
<p>
<b>Performance:</b> Uses SIMD-optimized maximum operation for 5-10x speedup.
</p>
</div>




  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_Round_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Round*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_Round_System_Byte_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Round(System.Byte)">
  Round(byte)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L502"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Rounds a byte value to the nearest integer (which is itself, since bytes are already integers).</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public byte Round(byte value)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>value</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The byte value to round.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The input value (since bytes are already integers).</p>
</dd>
  </dl>







  <h4 class="section" id="AiDotNet_Tensors_NumericOperations_ByteOperations_Round_System_Byte__remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>
Since bytes are already integer values, this method simply returns the input value.
</p>
<p><b>For Beginners:</b> This method rounds a number to the nearest whole number.
<p>Since bytes are already whole numbers, this simply returns the original value.</p>
<p>This method exists to maintain compatibility with other numeric types that need rounding.</p>

</div>




  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_Sigmoid_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Sigmoid*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_Sigmoid_System_ReadOnlySpan_System_Byte__System_Span_System_Byte__" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Sigmoid(System.ReadOnlySpan{System.Byte},System.Span{System.Byte})">
  Sigmoid(ReadOnlySpan&lt;byte&gt;, Span&lt;byte&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L755"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Transcendental operations are not supported for byte type.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void Sigmoid(ReadOnlySpan&lt;byte&gt; x, Span&lt;byte&gt; destination)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>x</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.readonlyspan-1">ReadOnlySpan</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd></dd>
    <dt><code>destination</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.span-1">Span</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd></dd>
  </dl>









  <h4 class="section">Exceptions</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.notsupportedexception">NotSupportedException</a></dt>
    <dd><p>Always thrown. Sigmoid saturates for byte inputs.</p>
</dd>
  </dl>



  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_SignOrZero_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.SignOrZero*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_SignOrZero_System_Byte_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.SignOrZero(System.Byte)">
  SignOrZero(byte)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L621"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Returns the sign of the specified value as a byte.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public byte SignOrZero(byte value)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>value</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The value to check.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>1 if the value is positive; 0 if the value is zero.</p>
</dd>
  </dl>







  <h4 class="section" id="AiDotNet_Tensors_NumericOperations_ByteOperations_SignOrZero_System_Byte__remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>
Since bytes are unsigned, this method returns 1 for any positive value and 0 for zero.
There is no negative representation in bytes.
</p>
<p><b>For Beginners:</b> This method determines the sign of a number.
<p>For regular numbers, the sign function returns:</p>
<ul>
<li>1 for positive numbers</li>
<li>0 for zero</li>
<li>-1 for negative numbers</li>
</ul>
<p>But since bytes can't be negative, this method only returns:</p>
<ul>
<li>1 for values greater than 0</li>
<li>0 for the value 0</li>
</ul>
<p>This is useful in algorithms that need to know the direction or sign of a value.</p>

</div>




  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_Sin_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Sin*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_Sin_System_Byte_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Sin(System.Byte)">
  Sin(byte)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L512"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Returns the sine of the specified value (truncated to integer).</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public byte Sin(byte value)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>value</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd></dd>
  </dl>








  <h4 class="section">Exceptions</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.notsupportedexception">NotSupportedException</a></dt>
    <dd><p>Trigonometric operations are not supported for byte type.</p>
</dd>
  </dl>



  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_Sin_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Sin*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_Sin_System_ReadOnlySpan_System_Byte__System_Span_System_Byte__" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Sin(System.ReadOnlySpan{System.Byte},System.Span{System.Byte})">
  Sin(ReadOnlySpan&lt;byte&gt;, Span&lt;byte&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L797"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Computes the sine of each element: destination[i] = sin(x[i]).</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void Sin(ReadOnlySpan&lt;byte&gt; x, Span&lt;byte&gt; destination)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>x</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.readonlyspan-1">ReadOnlySpan</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd><p>The source span (values in radians).</p>
</dd>
    <dt><code>destination</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.span-1">Span</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd><p>The destination span for results.</p>
</dd>
  </dl>








  <h4 class="section" id="AiDotNet_Tensors_NumericOperations_ByteOperations_Sin_System_ReadOnlySpan_System_Byte__System_Span_System_Byte___remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>
<b>For Beginners:</b> Sine is a trigonometric function that maps angles to values between -1 and 1.
Input values should be in radians. Used in positional encoding, spherical harmonics, and signal processing.
</p>
</div>




  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_SoftMax_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.SoftMax*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_SoftMax_System_ReadOnlySpan_System_Byte__System_Span_System_Byte__" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.SoftMax(System.ReadOnlySpan{System.Byte},System.Span{System.Byte})">
  SoftMax(ReadOnlySpan&lt;byte&gt;, Span&lt;byte&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L769"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Transcendental operations are not supported for byte type.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void SoftMax(ReadOnlySpan&lt;byte&gt; x, Span&lt;byte&gt; destination)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>x</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.readonlyspan-1">ReadOnlySpan</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd></dd>
    <dt><code>destination</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.span-1">Span</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd></dd>
  </dl>









  <h4 class="section">Exceptions</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.notsupportedexception">NotSupportedException</a></dt>
    <dd><p>Always thrown. SoftMax requires floating-point for normalized probabilities.</p>
</dd>
  </dl>



  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_Sqrt_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Sqrt*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_Sqrt_System_Byte_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Sqrt(System.Byte)">
  Sqrt(byte)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L206"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Calculates the square root of a byte value.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public byte Sqrt(byte value)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>value</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The value to calculate the square root of.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The square root of the specified value, casted to a byte.</p>
</dd>
  </dl>







  <h4 class="section" id="AiDotNet_Tensors_NumericOperations_ByteOperations_Sqrt_System_Byte__remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>
This method calculates the square root using Math.Sqrt and then casts the result to a byte.
Since the result is cast to a byte, any fractional part is truncated.
</p>
<p><b>For Beginners:</b> This method calculates the square root of a byte number.
<p>For example:</p>
<ul>
<li>The square root of 4 is 2</li>
<li>The square root of 9 is 3</li>
</ul>
<p>Because bytes can't have decimal parts:</p>
<ul>
<li>Square root of 5 becomes 2 (not 2.236...)</li>
<li>The decimal part is simply removed</li>
</ul>
<p>This works for all values from 0 to 255.</p>

</div>




  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_Sqrt_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Sqrt*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_Sqrt_System_ReadOnlySpan_System_Byte__System_Span_System_Byte__" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Sqrt(System.ReadOnlySpan{System.Byte},System.Span{System.Byte})">
  Sqrt(ReadOnlySpan&lt;byte&gt;, Span&lt;byte&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L785"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Computes the square root of each element: destination[i] = sqrt(x[i]).</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void Sqrt(ReadOnlySpan&lt;byte&gt; x, Span&lt;byte&gt; destination)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>x</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.readonlyspan-1">ReadOnlySpan</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd><p>The source span.</p>
</dd>
    <dt><code>destination</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.span-1">Span</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd><p>The destination span for results.</p>
</dd>
  </dl>












  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_Square_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Square*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_Square_System_Byte_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Square(System.Byte)">
  Square(byte)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L320"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Squares the specified byte value.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public byte Square(byte value)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>value</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The value to square.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The square of the specified value, casted to a byte.</p>
</dd>
  </dl>







  <h4 class="section" id="AiDotNet_Tensors_NumericOperations_ByteOperations_Square_System_Byte__remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>
This method multiplies the value by itself. If the result exceeds the maximum value of a byte (255),
the result will wrap around.
</p>
<p><b>For Beginners:</b> This method multiplies a number by itself.
<p>For example:</p>
<ul>
<li>Square of 2 is 4 (2  2)</li>
<li>Square of 10 is 100 (10  10)</li>
</ul>
<p>Because of byte limits:</p>
<ul>
<li>Square of 16 is 0 (16  16 = 256, which wraps to 0)</li>
<li>Any value of 16 or higher will wrap around when squared</li>
</ul>
<p>Be careful when squaring larger byte values.</p>

</div>




  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_Subtract_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Subtract*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_Subtract_System_Byte_System_Byte_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Subtract(System.Byte,System.Byte)">
  Subtract(byte, byte)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L75"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Subtracts the second byte value from the first.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public byte Subtract(byte a, byte b)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>a</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The value to subtract from.</p>
</dd>
    <dt><code>b</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The value to subtract.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The difference between the two values, casted to a byte.</p>
</dd>
  </dl>







  <h4 class="section" id="AiDotNet_Tensors_NumericOperations_ByteOperations_Subtract_System_Byte_System_Byte__remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>
If the result is negative, the value will wrap around. For example, 10 - 20 = 246 (as a byte)
because -10 wraps around to 246 in the byte range.
</p>
<p><b>For Beginners:</b> This method subtracts one byte number from another.
<p>Because bytes can't hold negative values:</p>
<ul>
<li>Normal subtractions like 20 - 10 = 10 work as expected</li>
<li>But 10 - 20 = 246 (not -10) because negative values wrap around from the other end</li>
</ul>
<p>The formula for finding the wrapped value is: 256 + negative_result</p>

</div>




  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_Subtract_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Subtract*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_Subtract_System_ReadOnlySpan_System_Byte__System_ReadOnlySpan_System_Byte__System_Span_System_Byte__" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Subtract(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Span{System.Byte})">
  Subtract(ReadOnlySpan&lt;byte&gt;, ReadOnlySpan&lt;byte&gt;, Span&lt;byte&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L691"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Performs element-wise subtraction using SIMD-optimized operations via TensorPrimitivesCore.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void Subtract(ReadOnlySpan&lt;byte&gt; x, ReadOnlySpan&lt;byte&gt; y, Span&lt;byte&gt; destination)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>x</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.readonlyspan-1">ReadOnlySpan</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd></dd>
    <dt><code>y</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.readonlyspan-1">ReadOnlySpan</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd></dd>
    <dt><code>destination</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.span-1">Span</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd></dd>
  </dl>












  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_SubtractScalar_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.SubtractScalar*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_SubtractScalar_System_ReadOnlySpan_System_Byte__System_Byte_System_Span_System_Byte__" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.SubtractScalar(System.ReadOnlySpan{System.Byte},System.Byte,System.Span{System.Byte})">
  SubtractScalar(ReadOnlySpan&lt;byte&gt;, byte, Span&lt;byte&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L784"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Subtracts a scalar from each element: destination[i] = x[i] - scalar.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void SubtractScalar(ReadOnlySpan&lt;byte&gt; x, byte scalar, Span&lt;byte&gt; destination)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>x</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.readonlyspan-1">ReadOnlySpan</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd><p>The source span.</p>
</dd>
    <dt><code>scalar</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The scalar value to subtract.</p>
</dd>
    <dt><code>destination</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.span-1">Span</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd><p>The destination span for results.</p>
</dd>
  </dl>












  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_Sum_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Sum*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_Sum_System_ReadOnlySpan_System_Byte__" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Sum(System.ReadOnlySpan{System.Byte})">
  Sum(ReadOnlySpan&lt;byte&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L715"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Computes sum using sequential loops.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public byte Sum(ReadOnlySpan&lt;byte&gt; x)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>x</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.readonlyspan-1">ReadOnlySpan</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd></dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd></dd>
  </dl>











  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_Swish_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Swish*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_Swish_System_ReadOnlySpan_System_Byte__System_Span_System_Byte__" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Swish(System.ReadOnlySpan{System.Byte},System.Span{System.Byte})">
  Swish(ReadOnlySpan&lt;byte&gt;, Span&lt;byte&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L828"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Computes Swish/SiLU activation element-wise: x * sigmoid(x) = x / (1 + exp(-x)).</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void Swish(ReadOnlySpan&lt;byte&gt; x, Span&lt;byte&gt; destination)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>x</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.readonlyspan-1">ReadOnlySpan</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd><p>The source span.</p>
</dd>
    <dt><code>destination</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.span-1">Span</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd><p>The destination span for results.</p>
</dd>
  </dl>








  <h4 class="section" id="AiDotNet_Tensors_NumericOperations_ByteOperations_Swish_System_ReadOnlySpan_System_Byte__System_Span_System_Byte___remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>
<b>For Beginners:</b> Swish (also called SiLU - Sigmoid Linear Unit) is a smooth,
non-monotonic activation function that often outperforms ReLU. It allows negative
values to pass through, helping with gradient flow.
</p>
<p>
<b>Performance:</b> Uses SIMD-optimized sigmoid and multiplication operations
for 2-4x speedup over scalar implementation.
</p>
</div>




  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_Tanh_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Tanh*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_Tanh_System_ReadOnlySpan_System_Byte__System_Span_System_Byte__" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.Tanh(System.ReadOnlySpan{System.Byte},System.Span{System.Byte})">
  Tanh(ReadOnlySpan&lt;byte&gt;, Span&lt;byte&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L748"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Transcendental operations are not supported for byte type.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void Tanh(ReadOnlySpan&lt;byte&gt; x, Span&lt;byte&gt; destination)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>x</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.readonlyspan-1">ReadOnlySpan</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd></dd>
    <dt><code>destination</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.span-1">Span</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd></dd>
  </dl>









  <h4 class="section">Exceptions</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.notsupportedexception">NotSupportedException</a></dt>
    <dd><p>Always thrown. Tanh produces only 0 or 1 for bytes.</p>
</dd>
  </dl>



  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_ToDouble_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.ToDouble*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_ToDouble_System_Byte_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.ToDouble(System.Byte)">
  ToDouble(byte)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L672"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Converts a byte value to double (FP64) precision.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public double ToDouble(byte value)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>value</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The byte value to convert.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.double">double</a></dt>
    <dd><p>The value as a double.</p>
</dd>
  </dl>











  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_ToFloat_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.ToFloat*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_ToFloat_System_Byte_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.ToFloat(System.Byte)">
  ToFloat(byte)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L638"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Converts a byte value to float (FP32) precision.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public float ToFloat(byte value)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>value</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The byte value to convert.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.single">float</a></dt>
    <dd><p>The value as a float.</p>
</dd>
  </dl>











  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_ToFloatSpan_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.ToFloatSpan*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_ToFloatSpan_System_ReadOnlySpan_System_Byte__System_Span_System_Single__" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.ToFloatSpan(System.ReadOnlySpan{System.Byte},System.Span{System.Single})">
  ToFloatSpan(ReadOnlySpan&lt;byte&gt;, Span&lt;float&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L807"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Converts elements from type T to float (FP32): destination[i] = (float)source[i].</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void ToFloatSpan(ReadOnlySpan&lt;byte&gt; source, Span&lt;float&gt; destination)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>source</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.readonlyspan-1">ReadOnlySpan</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd><p>The source span containing values of type T.</p>
</dd>
    <dt><code>destination</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.span-1">Span</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.single">float</a>&gt;</dt>
    <dd><p>The destination span for float results.</p>
</dd>
  </dl>








  <h4 class="section" id="AiDotNet_Tensors_NumericOperations_ByteOperations_ToFloatSpan_System_ReadOnlySpan_System_Byte__System_Span_System_Single___remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>
<b>For Beginners:</b> This method converts an array of numbers from one type (like double or int)
to 32-bit floating-point numbers. This is commonly used when preparing data for GPU processing,
which typically operates on float32 for optimal performance.
</p>
<p>
<b>Performance:</b> This operation can be SIMD-accelerated using TensorPrimitives.ConvertToSingle
on .NET 8+, providing significant speedup over sequential conversion loops.
</p>
</div>




  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_ToHalf_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.ToHalf*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_ToHalf_System_Byte_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.ToHalf(System.Byte)">
  ToHalf(byte)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L655"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Converts a byte value to Half (FP16) precision.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public Half ToHalf(byte value)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>value</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The byte value to convert.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.half">Half</a></dt>
    <dd><p>The value as a Half.</p>
</dd>
  </dl>











  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_ToHalfSpan_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.ToHalfSpan*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_ToHalfSpan_System_ReadOnlySpan_System_Byte__System_Span_System_Half__" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.ToHalfSpan(System.ReadOnlySpan{System.Byte},System.Span{System.Half})">
  ToHalfSpan(ReadOnlySpan&lt;byte&gt;, Span&lt;Half&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L813"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Converts elements from type T to Half (FP16): destination[i] = (Half)source[i].</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void ToHalfSpan(ReadOnlySpan&lt;byte&gt; source, Span&lt;Half&gt; destination)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>source</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.readonlyspan-1">ReadOnlySpan</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>&gt;</dt>
    <dd><p>The source span containing values of type T.</p>
</dd>
    <dt><code>destination</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.span-1">Span</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.half">Half</a>&gt;</dt>
    <dd><p>The destination span for Half results.</p>
</dd>
  </dl>








  <h4 class="section" id="AiDotNet_Tensors_NumericOperations_ByteOperations_ToHalfSpan_System_ReadOnlySpan_System_Byte__System_Span_System_Half___remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>
<b>For Beginners:</b> This method converts an array of numbers to 16-bit half-precision
floating-point numbers. Half precision uses less memory and can be faster on GPUs that
support it, at the cost of reduced precision and range.
</p>
<p>
<b>Performance:</b> This operation can be SIMD-accelerated using TensorPrimitives.ConvertToHalf
on .NET 8+, providing significant speedup over sequential conversion loops. Critical for
mixed-precision GPU operations where FP16 loads with FP32 accumulation provides 2x speedup.
</p>
</div>




  <a id="AiDotNet_Tensors_NumericOperations_ByteOperations_ToInt32_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.ToInt32*"></a>

  <h3 id="AiDotNet_Tensors_NumericOperations_ByteOperations_ToInt32_System_Byte_" data-uid="AiDotNet.Tensors.NumericOperations.ByteOperations.ToInt32(System.Byte)">
  ToInt32(byte)
  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L484"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Converts a byte value to a 32-bit integer.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public int ToInt32(byte value)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>value</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a></dt>
    <dd><p>The byte value to convert.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd><p>The byte value as a 32-bit integer.</p>
</dd>
  </dl>







  <h4 class="section" id="AiDotNet_Tensors_NumericOperations_ByteOperations_ToInt32_System_Byte__remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>
This method converts a byte to an Int32. Since a byte can only hold values from 0 to 255,
the conversion is always safe and will never overflow.
</p>
<p><b>For Beginners:</b> This method converts a byte to a regular integer.
<p>The conversion is straightforward:</p>
<ul>
<li>A byte like 5 becomes the integer 5</li>
<li>A byte like 255 becomes the integer 255</li>
</ul>
<p>This is useful when you need to use a byte value with operations that expect a larger number type.</p>

</div>





</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/ooples/AiDotNet/blob/master/src/AiDotNet.Tensors/NumericOperations/ByteOperations.cs/#L31" class="edit-link">Edit this page</a>
        </div>


      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          AiDotNet - Enterprise AI/ML Library for .NET
        </div>
      </div>
    </footer>
  </body>
</html>
