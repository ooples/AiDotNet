<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Enum SSAAlgorithmType | AiDotNet Documentation </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Enum SSAAlgorithmType | AiDotNet Documentation ">
      
      <meta name="description" content="Represents different algorithm types for Singular Spectrum Analysis (SSA).">
      <link rel="icon" href="../favicon.ico">
      <link rel="stylesheet" href="../public/docfx.min.css">
      <link rel="stylesheet" href="../public/main.css">
      <meta name="docfx:navrel" content="../toc.html">
      <meta name="docfx:tocrel" content="toc.html">
      
      <meta name="docfx:rel" content="../">
      
      
      <meta name="docfx:docurl" content="https://github.com/ooples/AiDotNet/new/master/apiSpec/new?filename=AiDotNet_Enums_AlgorithmTypes_SSAAlgorithmType.md&amp;value=---%0Auid%3A%20AiDotNet.Enums.AlgorithmTypes.SSAAlgorithmType%0Asummary%3A%20&#39;*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax&#39;%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="ManagedReference">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../index.html">
            <img id="logo" class="svg" src="../logo.svg" alt="AiDotNet">
            AiDotNet
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="AiDotNet.Enums.AlgorithmTypes.SSAAlgorithmType">




  <h1 id="AiDotNet_Enums_AlgorithmTypes_SSAAlgorithmType" data-uid="AiDotNet.Enums.AlgorithmTypes.SSAAlgorithmType" class="text-break">
Enum SSAAlgorithmType  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/Enums/AlgorithmTypes/SSAAlgorithmType.cs/#L45"><i class="bi bi-code-slash"></i></a>
  </h1>

  <div class="facts text-secondary">
    <dl><dt>Namespace</dt><dd><a class="xref" href="AiDotNet.html">AiDotNet</a>.<a class="xref" href="AiDotNet.Enums.html">Enums</a>.<a class="xref" href="AiDotNet.Enums.AlgorithmTypes.html">AlgorithmTypes</a></dd></dl>
  <dl><dt>Assembly</dt><dd>AiDotNet.dll</dd></dl>
  </div>

  <div class="markdown summary"><p>Represents different algorithm types for Singular Spectrum Analysis (SSA).</p>
</div>
  <div class="markdown conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public enum SSAAlgorithmType</code></pre>
  </div>









  <h2 id="fields">Fields
</h2>
  <dl class="parameters">
    <dt id="AiDotNet_Enums_AlgorithmTypes_SSAAlgorithmType_Basic"><code>Basic = 0</code></dt>
  <dd><p>Uses the standard basic implementation of Singular Spectrum Analysis.</p>
<p>
<b>For Beginners:</b> The Basic SSA algorithm follows the classic four-step approach described above: embedding, 
decomposition, grouping, and reconstruction.
<p>Imagine sorting through a box of mixed Lego pieces. The Basic SSA approach would be like:</p>
<ol>
<li>Organizing the pieces into rows based on their size (embedding)</li>
<li>Identifying common patterns or shapes among the pieces (decomposition)</li>
<li>Grouping similar pieces together (grouping)</li>
<li>Using selected groups to build something new (reconstruction)</li>
</ol>
<p>The Basic approach:</p>
<ol>
<li><p>Is the most straightforward implementation of SSA</p>
</li>
<li><p>Works well for most standard time series analysis tasks</p>
</li>
<li><p>Provides a good balance between computational efficiency and accuracy</p>
</li>
<li><p>Is easier to understand and interpret</p>
</li>
<li><p>Serves as a foundation for more specialized variants</p>
</li>
</ol>
<p>This method is particularly useful when:</p>
<ol>
<li><p>You're new to SSA and want to start with the standard approach</p>
</li>
<li><p>Your time series is well-behaved (not too noisy or irregular)</p>
</li>
<li><p>You want results that are easy to interpret</p>
</li>
<li><p>You're exploring the data to get a general understanding of its components</p>
</li>
</ol>
<p>In machine learning applications, the Basic SSA algorithm provides a solid foundation for feature extraction
from time series data, helping to identify patterns that can improve the performance of predictive models.</p>

</dd>
  
    <dt id="AiDotNet_Enums_AlgorithmTypes_SSAAlgorithmType_Sequential"><code>Sequential = 1</code></dt>
  <dd><p>Uses a sequential implementation of SSA that processes data in a step-by-step manner.</p>
<p>
<b>For Beginners:</b> The Sequential SSA algorithm processes the time series data in a step-by-step manner, 
updating the decomposition as new data points become available.
<p>Think of it like reading a book one page at a time and continuously updating your understanding of the
story, rather than reading the whole book at once:</p>
<ol>
<li>You start with a small portion of the data</li>
<li>Perform the SSA steps on this portion</li>
<li>When new data arrives, you update your analysis without starting over</li>
<li>This continues as more data becomes available</li>
</ol>
<p>The Sequential approach:</p>
<ol>
<li><p>Is more efficient for processing streaming or real-time data</p>
</li>
<li><p>Requires less memory since it doesn't need to store the entire dataset at once</p>
</li>
<li><p>Can adapt to changes in the data patterns over time</p>
</li>
<li><p>Is suitable for online learning scenarios</p>
</li>
<li><p>May sacrifice some accuracy compared to processing all data at once</p>
</li>
</ol>
<p>This method is particularly valuable when:</p>
<ol>
<li><p>You're working with streaming data that arrives continuously</p>
</li>
<li><p>You have limited memory resources</p>
</li>
<li><p>You need to update your analysis in real-time</p>
</li>
<li><p>The patterns in your data might evolve over time</p>
</li>
</ol>
<p>In machine learning applications, Sequential SSA enables real-time feature extraction and pattern recognition,
making it useful for applications like predictive maintenance, anomaly detection in IoT sensors, or financial
market analysis where immediate insights are valuable.</p>

</dd>
  
    <dt id="AiDotNet_Enums_AlgorithmTypes_SSAAlgorithmType_Toeplitz"><code>Toeplitz = 2</code></dt>
  <dd><p>Uses a Toeplitz matrix approach for SSA, which exploits the structure of time series data.</p>
<p>
<b>For Beginners:</b> The Toeplitz SSA algorithm uses a special type of matrix called a Toeplitz matrix during 
the embedding step, which has a unique pattern where each diagonal contains the same value.
<p>Imagine a staircase where each step has the same pattern repeated. A Toeplitz matrix has a similar
repeating pattern, which makes calculations more efficient:</p>
<ol>
<li>Instead of creating the full trajectory matrix, it uses the special Toeplitz structure</li>
<li>This structure allows for faster computations and less memory usage</li>
<li>The mathematical properties of Toeplitz matrices enable specialized, efficient algorithms</li>
</ol>
<p>The Toeplitz approach:</p>
<ol>
<li><p>Is computationally more efficient than the basic approach, especially for large datasets</p>
</li>
<li><p>Reduces memory requirements by exploiting the matrix structure</p>
</li>
<li><p>Produces results that are mathematically equivalent to the basic approach</p>
</li>
<li><p>Works particularly well for stationary time series (those with consistent statistical properties)</p>
</li>
<li><p>Can handle longer time series more effectively</p>
</li>
</ol>
<p>This method is particularly useful when:</p>
<ol>
<li><p>You're working with very large time series datasets</p>
</li>
<li><p>Computational efficiency is important</p>
</li>
<li><p>Your data has relatively stable statistical properties</p>
</li>
<li><p>You need to process many time series quickly</p>
</li>
</ol>
<p>In machine learning applications, the Toeplitz SSA algorithm enables efficient processing of large-scale
time series data, making it practical to extract features from extensive historical datasets or to apply
SSA to high-frequency data like audio signals or high-resolution sensor readings.</p>

</dd>
  
  </dl>


  <h2 id="AiDotNet_Enums_AlgorithmTypes_SSAAlgorithmType_remarks">Remarks</h2>
  <div class="markdown level0 remarks"><p>
<b>For Beginners:</b> Singular Spectrum Analysis (SSA) is a powerful technique used to analyze time series data 
by breaking it down into meaningful components. Think of it as taking apart a complex musical piece to 
identify the individual instruments playing.
<p>Here's how SSA works in simple terms:</p>
<ol>
<li><p>Embedding: First, we take our time series (a sequence of values over time) and create a matrix by sliding
a window of a certain length through the data. Each column of this matrix represents a segment of our
original time series.</p>
</li>
<li><p>Decomposition: Next, we perform a mathematical operation called Singular Value Decomposition (SVD) on this
matrix. This breaks down our matrix into simpler components, each capturing different patterns in the data.</p>
</li>
<li><p>Grouping: We then group these components based on their properties. Some might represent trends, others
seasonal patterns, and some just random noise.</p>
</li>
<li><p>Reconstruction: Finally, we can reconstruct our time series using only the components we're interested in,
effectively filtering out unwanted patterns.</p>
</li>
</ol>
<p>Why is SSA important in AI and machine learning?</p>
<ol>
<li><p>Noise Reduction: It can clean up noisy data by separating signal from noise</p>
</li>
<li><p>Trend Extraction: It can identify and isolate long-term trends in data</p>
</li>
<li><p>Seasonality Detection: It can extract seasonal patterns of various frequencies</p>
</li>
<li><p>Feature Engineering: The components extracted can serve as features for machine learning models</p>
</li>
<li><p>Forecasting: By understanding the underlying patterns, we can make better predictions</p>
</li>
<li><p>Anomaly Detection: Unusual patterns that don't fit the main components can be identified as anomalies</p>
</li>
</ol>
<p>This enum specifies which specific algorithm variant to use for SSA, as different methods have different
performance characteristics and may be more suitable for certain types of data or analysis goals.</p>

</div>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/ooples/AiDotNet/blob/master/src/Enums/AlgorithmTypes/SSAAlgorithmType.cs/#L45" class="edit-link">Edit this page</a>
        </div>


      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          AiDotNet - Enterprise AI/ML Library for .NET
        </div>
      </div>
    </footer>
  </body>
</html>
