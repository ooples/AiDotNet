<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Enum LqAlgorithmType | AiDotNet Documentation </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Enum LqAlgorithmType | AiDotNet Documentation ">
      
      <meta name="description" content="Represents different algorithm types for LQ decomposition of matrices.">
      <link rel="icon" href="../favicon.ico">
      <link rel="stylesheet" href="../public/docfx.min.css">
      <link rel="stylesheet" href="../public/main.css">
      <meta name="docfx:navrel" content="../toc.html">
      <meta name="docfx:tocrel" content="toc.html">
      
      <meta name="docfx:rel" content="../">
      
      
      <meta name="docfx:docurl" content="https://github.com/ooples/AiDotNet/new/master/apiSpec/new?filename=AiDotNet_Enums_AlgorithmTypes_LqAlgorithmType.md&amp;value=---%0Auid%3A%20AiDotNet.Enums.AlgorithmTypes.LqAlgorithmType%0Asummary%3A%20&#39;*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax&#39;%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="ManagedReference">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../index.html">
            <img id="logo" class="svg" src="../logo.svg" alt="AiDotNet">
            AiDotNet
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="AiDotNet.Enums.AlgorithmTypes.LqAlgorithmType">




  <h1 id="AiDotNet_Enums_AlgorithmTypes_LqAlgorithmType" data-uid="AiDotNet.Enums.AlgorithmTypes.LqAlgorithmType" class="text-break">
Enum LqAlgorithmType  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/Enums/AlgorithmTypes/LqAlgorithmType.cs/#L41"><i class="bi bi-code-slash"></i></a>
  </h1>

  <div class="facts text-secondary">
    <dl><dt>Namespace</dt><dd><a class="xref" href="AiDotNet.html">AiDotNet</a>.<a class="xref" href="AiDotNet.Enums.html">Enums</a>.<a class="xref" href="AiDotNet.Enums.AlgorithmTypes.html">AlgorithmTypes</a></dd></dl>
  <dl><dt>Assembly</dt><dd>AiDotNet.dll</dd></dl>
  </div>

  <div class="markdown summary"><p>Represents different algorithm types for LQ decomposition of matrices.</p>
</div>
  <div class="markdown conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public enum LqAlgorithmType</code></pre>
  </div>









  <h2 id="fields">Fields
</h2>
  <dl class="parameters">
    <dt id="AiDotNet_Enums_AlgorithmTypes_LqAlgorithmType_Givens"><code>Givens = 2</code></dt>
  <dd><p>Uses Givens rotations to compute the LQ factorization.</p>
<p>
<b>For Beginners:</b> The Givens method uses a series of simple rotations to gradually transform the 
original matrix into the L and Q components.
<p>Imagine you're adjusting the position of a picture frame on a wall. Instead of moving it all at once,
you make small rotations - a little to the left, a little up, etc. - until it's perfectly aligned.
Givens rotations work similarly by making a series of simple rotations to transform the matrix.</p>
<p>The Givens method:</p>
<ol>
<li><p>Is very precise and numerically stable</p>
</li>
<li><p>Can target specific elements of the matrix (unlike Householder which affects entire rows)</p>
</li>
<li><p>Works well for sparse matrices (matrices with lots of zeros)</p>
</li>
<li><p>Is excellent for making small updates to an existing decomposition</p>
</li>
<li><p>Can be easily parallelized for certain matrix structures</p>
</li>
</ol>
<p>While generally slower than Householder for dense matrices, Givens rotations excel when working with
sparse matrices or when you need to update an existing decomposition without recalculating everything.</p>
<p>In machine learning, this is particularly useful for online learning scenarios where data arrives
sequentially and you want to update your model incrementally, or when working with sparse feature
matrices common in text analysis or recommendation systems.</p>

</dd>
  
    <dt id="AiDotNet_Enums_AlgorithmTypes_LqAlgorithmType_GramSchmidt"><code>GramSchmidt = 1</code></dt>
  <dd><p>Uses the Gram-Schmidt process to compute the LQ factorization.</p>
<p>
<b>For Beginners:</b> The Gram-Schmidt method works by taking the rows of your matrix and making them 
perpendicular (orthogonal) to each other, one at a time.
<p>Imagine you're arranging furniture in a room. You place the first piece wherever you want. For the
second piece, you make sure it's aligned with the walls (perpendicular). For the third piece, you
make sure it's aligned with both the walls and doesn't interfere with the previous pieces.
Gram-Schmidt works similarly by &quot;aligning&quot; each row with respect to previous rows.</p>
<p>The Gram-Schmidt method:</p>
<ol>
<li><p>Is conceptually simpler and easier to understand than other methods</p>
</li>
<li><p>Works well for small matrices or when you need to explain the process</p>
</li>
<li><p>Is more straightforward to implement from scratch</p>
</li>
<li><p>Can be modified to work incrementally (row by row)</p>
</li>
</ol>
<p>However, the classical Gram-Schmidt method can suffer from numerical instability with larger matrices.
Modern implementations use a modified version that improves stability.</p>
<p>In machine learning, this method is useful for educational purposes, for smaller problems, or when
you need to process data incrementally (one row at a time) rather than all at once.</p>

</dd>
  
    <dt id="AiDotNet_Enums_AlgorithmTypes_LqAlgorithmType_Householder"><code>Householder = 0</code></dt>
  <dd><p>Uses Householder reflections to compute the LQ factorization.</p>
<p>
<b>For Beginners:</b> The Householder method uses special mathematical operations called "reflections" 
to gradually transform the original matrix into the L and Q components.
<p>Imagine you're folding origami - each fold (reflection) transforms your paper in a specific way.
After a series of carefully chosen folds, you end up with your desired shape. Householder reflections
work similarly to transform matrices.</p>
<p>The Householder method:</p>
<ol>
<li><p>Is numerically very stable (resistant to calculation errors)</p>
</li>
<li><p>Works efficiently for most types of matrices</p>
</li>
<li><p>Requires less computation than other methods for large matrices</p>
</li>
<li><p>Preserves the structure of sparse matrices better than some alternatives</p>
</li>
</ol>
<p>This is typically the default choice for LQ decomposition in most applications because it offers
an excellent balance of stability, accuracy, and efficiency.</p>
<p>In machine learning, this is particularly useful for solving large least squares problems, such as
in linear regression with many features, or when processing large datasets where numerical stability
is important.</p>

</dd>
  
  </dl>


  <h2 id="AiDotNet_Enums_AlgorithmTypes_LqAlgorithmType_remarks">Remarks</h2>
  <div class="markdown level0 remarks"><p>
<b>For Beginners:</b> LQ decomposition is a way to break down a matrix into two simpler parts that make 
calculations much easier and faster.
<p>Imagine you have a complex recipe (the matrix) that you need to follow. LQ decomposition breaks this recipe
into two simpler steps:</p>
<ol>
<li>L - A lower triangular matrix (has values only on and below the diagonal)</li>
<li>Q - An orthogonal matrix (a special type of matrix where columns/rows are perpendicular to each other)</li>
</ol>
<p>So instead of following one complex recipe, you can follow two simpler ones in sequence.</p>
<p>Why is this important in AI and machine learning?</p>
<ol>
<li><p>Solving Least Squares Problems: Many machine learning algorithms involve finding the best fit for data,
which often requires solving least squares problems.</p>
</li>
<li><p>Dimensionality Reduction: LQ decomposition can help reduce the number of features in your data while
preserving important information.</p>
</li>
<li><p>Data Transformation: It allows you to transform your data into a more useful form for analysis.</p>
</li>
<li><p>Numerical Stability: LQ decomposition provides a stable way to perform calculations that might otherwise
be prone to errors.</p>
</li>
<li><p>Feature Extraction: It can help identify the most important features in your data.</p>
</li>
</ol>
<p>LQ decomposition is closely related to QR decomposition (which is more commonly discussed), but LQ works
on the rows of a matrix rather than the columns. Think of it as QR decomposition's &quot;mirror image.&quot;</p>
<p>This enum specifies which specific algorithm to use for performing the LQ decomposition, as different
methods have different performance characteristics depending on the matrix properties.</p>

</div>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/ooples/AiDotNet/blob/master/src/Enums/AlgorithmTypes/LqAlgorithmType.cs/#L41" class="edit-link">Edit this page</a>
        </div>


      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          AiDotNet - Enterprise AI/ML Library for .NET
        </div>
      </div>
    </footer>
  </body>
</html>
