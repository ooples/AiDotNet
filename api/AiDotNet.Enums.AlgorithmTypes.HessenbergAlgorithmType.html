<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Enum HessenbergAlgorithmType | AiDotNet Documentation </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Enum HessenbergAlgorithmType | AiDotNet Documentation ">
      
      <meta name="description" content="Represents different algorithm types for Hessenberg decomposition of matrices.">
      <link rel="icon" href="../favicon.ico">
      <link rel="stylesheet" href="../public/docfx.min.css">
      <link rel="stylesheet" href="../public/main.css">
      <meta name="docfx:navrel" content="../toc.html">
      <meta name="docfx:tocrel" content="toc.html">
      
      <meta name="docfx:rel" content="../">
      
      
      <meta name="docfx:docurl" content="https://github.com/ooples/AiDotNet/new/master/apiSpec/new?filename=AiDotNet_Enums_AlgorithmTypes_HessenbergAlgorithmType.md&amp;value=---%0Auid%3A%20AiDotNet.Enums.AlgorithmTypes.HessenbergAlgorithmType%0Asummary%3A%20&#39;*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax&#39;%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="ManagedReference">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../index.html">
            <img id="logo" class="svg" src="../logo.svg" alt="AiDotNet">
            AiDotNet
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="AiDotNet.Enums.AlgorithmTypes.HessenbergAlgorithmType">




  <h1 id="AiDotNet_Enums_AlgorithmTypes_HessenbergAlgorithmType" data-uid="AiDotNet.Enums.AlgorithmTypes.HessenbergAlgorithmType" class="text-break">
Enum HessenbergAlgorithmType  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/Enums/AlgorithmTypes/HessenbergAlgorithmType.cs/#L34"><i class="bi bi-code-slash"></i></a>
  </h1>

  <div class="facts text-secondary">
    <dl><dt>Namespace</dt><dd><a class="xref" href="AiDotNet.html">AiDotNet</a>.<a class="xref" href="AiDotNet.Enums.html">Enums</a>.<a class="xref" href="AiDotNet.Enums.AlgorithmTypes.html">AlgorithmTypes</a></dd></dl>
  <dl><dt>Assembly</dt><dd>AiDotNet.dll</dd></dl>
  </div>

  <div class="markdown summary"><p>Represents different algorithm types for Hessenberg decomposition of matrices.</p>
</div>
  <div class="markdown conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public enum HessenbergAlgorithmType</code></pre>
  </div>









  <h2 id="fields">Fields
</h2>
  <dl class="parameters">
    <dt id="AiDotNet_Enums_AlgorithmTypes_HessenbergAlgorithmType_ElementaryTransformations"><code>ElementaryTransformations = 2</code></dt>
  <dd><p>Uses elementary transformations to compute the Hessenberg form.</p>
<p>
<b>For Beginners:</b> The Elementary Transformations method uses the most basic matrix operations to transform 
a matrix into Hessenberg form.
<p>These operations are like the fundamental building blocks of matrix manipulation - simple operations like
multiplying a row by a constant, adding one row to another, or swapping rows. Think of it like cooking
with just the most basic ingredients and techniques.</p>
<p>This approach:</p>
<ol>
<li><p>Is conceptually simpler and easier to understand</p>
</li>
<li><p>Can be useful for educational purposes</p>
</li>
<li><p>Works well for certain specialized matrix structures</p>
</li>
<li><p>May be easier to implement in some programming environments</p>
</li>
</ol>
<p>However, it's generally less computationally efficient and less numerically stable than methods like
Householder or Givens for general-purpose use. It's most appropriate for small matrices or special cases
where its simplicity offers an advantage.</p>

</dd>
  
    <dt id="AiDotNet_Enums_AlgorithmTypes_HessenbergAlgorithmType_Givens"><code>Givens = 1</code></dt>
  <dd><p>Uses Givens rotations to compute the Hessenberg form.</p>
<p>
<b>For Beginners:</b> The Givens method uses mathematical operations called "rotations" to transform a matrix 
into Hessenberg form.
<p>While Householder reflections flip entire spaces at once, Givens rotations are more like turning a dial -
they rotate just two rows or columns at a time. Imagine adjusting just two sliders on a mixing board
rather than moving all sliders at once.</p>
<p>The Givens method is particularly useful when:</p>
<ol>
<li><p>Working with sparse matrices (matrices with mostly zeros)</p>
</li>
<li><p>You need to preserve certain structures in your matrix</p>
</li>
<li><p>You're updating an existing decomposition after small changes to the original matrix</p>
</li>
<li><p>Working with matrices that have special patterns</p>
</li>
</ol>
<p>While generally slower than Householder for dense matrices, Givens rotations can be more efficient for
certain specialized applications where you only need to modify a few elements of the matrix.</p>

</dd>
  
    <dt id="AiDotNet_Enums_AlgorithmTypes_HessenbergAlgorithmType_Householder"><code>Householder = 0</code></dt>
  <dd><p>Uses Householder reflections to compute the Hessenberg form.</p>
<p>
<b>For Beginners:</b> The Householder method uses special mathematical operations called "reflections" to 
transform a matrix into Hessenberg form.
<p>Imagine you're rearranging furniture in a room by flipping the entire room over an imaginary line -
that's similar to how a Householder reflection works. It reflects vectors across carefully chosen planes
to zero out elements in the matrix.</p>
<p>The Householder method is:</p>
<ol>
<li><p>Very numerically stable (resistant to rounding errors)</p>
</li>
<li><p>Efficient for dense matrices (matrices where most elements are non-zero)</p>
</li>
<li><p>The most commonly used method in practice</p>
</li>
<li><p>Well-suited for parallel computing</p>
</li>
</ol>
<p>This is typically the default choice for Hessenberg decomposition because of its excellent balance of
stability and performance across a wide range of matrix types.</p>

</dd>
  
    <dt id="AiDotNet_Enums_AlgorithmTypes_HessenbergAlgorithmType_ImplicitQR"><code>ImplicitQR = 3</code></dt>
  <dd><p>Uses the Implicit QR algorithm to compute the Hessenberg form.</p>
<p>
<b>For Beginners:</b> The Implicit QR method combines Hessenberg decomposition with eigenvalue calculations in 
a single, efficient process.
<p>Rather than first converting to Hessenberg form and then finding eigenvalues, this method does both
simultaneously. It's like cooking a one-pot meal instead of preparing each ingredient separately.</p>
<p>The Implicit QR method:</p>
<ol>
<li><p>Is highly efficient when you need both the Hessenberg form and eigenvalues</p>
</li>
<li><p>Reduces the total number of operations required</p>
</li>
<li><p>Often has better numerical properties for the combined task</p>
</li>
<li><p>Is the method of choice in many professional numerical libraries</p>
</li>
</ol>
<p>This method is particularly valuable in applications like principal component analysis (PCA), signal
processing, and vibration analysis, where eigenvalues are the ultimate goal of the computation.</p>

</dd>
  
    <dt id="AiDotNet_Enums_AlgorithmTypes_HessenbergAlgorithmType_Lanczos"><code>Lanczos = 4</code></dt>
  <dd><p>Uses the Lanczos algorithm to compute the Hessenberg form for symmetric matrices.</p>
<p>
<b>For Beginners:</b> The Lanczos method is a specialized algorithm designed specifically for symmetric matrices 
(matrices that are mirror images across their diagonal).
<p>For symmetric matrices, the Hessenberg form is actually tridiagonal (non-zero elements only on the main
diagonal and the diagonals just above and below it). The Lanczos algorithm exploits this special structure
to work much more efficiently.</p>
<p>Imagine having a shortcut through a maze because you know a special property of the maze - that's what
Lanczos does by taking advantage of matrix symmetry.</p>
<p>The Lanczos method:</p>
<ol>
<li><p>Is extremely efficient for large, symmetric matrices</p>
</li>
<li><p>Uses much less memory than other methods</p>
</li>
<li><p>Can find approximate eigenvalues without computing the full decomposition</p>
</li>
<li><p>Is particularly useful in quantum mechanics, structural analysis, and graph theory applications</p>
</li>
</ol>
<p>This method should only be used with symmetric matrices. For non-symmetric matrices, one of the other
methods should be chosen instead.</p>

</dd>
  
  </dl>


  <h2 id="AiDotNet_Enums_AlgorithmTypes_HessenbergAlgorithmType_remarks">Remarks</h2>
  <div class="markdown level0 remarks"><p>
<b>For Beginners:</b> Hessenberg decomposition is a way to transform a complex matrix into a simpler form 
that makes further calculations much easier and faster.
<p>Imagine you have a cluttered desk with papers scattered everywhere. Hessenberg decomposition is like
organizing that desk so that all papers are neatly stacked in one corner, making it much easier to
find what you need. In mathematical terms, it transforms a matrix so that all elements below the first
subdiagonal are zero (creating a staircase-like pattern).</p>
<p>Why is this important in AI and machine learning?</p>
<ol>
<li><p>Eigenvalue Calculations: Many AI algorithms need to find eigenvalues of matrices (special values that
help understand the fundamental properties of data). Hessenberg form makes finding these values much faster.</p>
</li>
<li><p>Computational Efficiency: Converting to Hessenberg form reduces the number of operations needed for
many matrix calculations from O(n³) to O(n²), making algorithms run much faster for large datasets.</p>
</li>
<li><p>Numerical Stability: These transformations improve the accuracy of calculations by reducing
rounding errors that can accumulate when working with floating-point numbers.</p>
</li>
<li><p>Dimensionality Reduction: In some machine learning applications, Hessenberg decomposition can help
identify important patterns in high-dimensional data.</p>
</li>
</ol>
<p>This enum specifies which specific algorithm to use for performing the Hessenberg decomposition, as
different methods have different performance characteristics depending on the matrix size and structure.</p>

</div>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/ooples/AiDotNet/blob/master/src/Enums/AlgorithmTypes/HessenbergAlgorithmType.cs/#L34" class="edit-link">Edit this page</a>
        </div>


      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          AiDotNet - Enterprise AI/ML Library for .NET
        </div>
      </div>
    </footer>
  </body>
</html>
