<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Enum SchurAlgorithmType | AiDotNet Documentation </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Enum SchurAlgorithmType | AiDotNet Documentation ">
      
      <meta name="description" content="Represents different algorithm types for computing the Schur decomposition of matrices.">
      <link rel="icon" href="../favicon.ico">
      <link rel="stylesheet" href="../public/docfx.min.css">
      <link rel="stylesheet" href="../public/main.css">
      <meta name="docfx:navrel" content="../toc.html">
      <meta name="docfx:tocrel" content="toc.html">
      
      <meta name="docfx:rel" content="../">
      
      
      <meta name="docfx:docurl" content="https://github.com/ooples/AiDotNet/new/master/apiSpec/new?filename=AiDotNet_Enums_AlgorithmTypes_SchurAlgorithmType.md&amp;value=---%0Auid%3A%20AiDotNet.Enums.AlgorithmTypes.SchurAlgorithmType%0Asummary%3A%20&#39;*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax&#39;%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="ManagedReference">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../index.html">
            <img id="logo" class="svg" src="../logo.svg" alt="AiDotNet">
            AiDotNet
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="AiDotNet.Enums.AlgorithmTypes.SchurAlgorithmType">




  <h1 id="AiDotNet_Enums_AlgorithmTypes_SchurAlgorithmType" data-uid="AiDotNet.Enums.AlgorithmTypes.SchurAlgorithmType" class="text-break">
Enum SchurAlgorithmType  <a class="header-action link-secondary" title="View source" href="https://github.com/ooples/AiDotNet/blob/master/src/Enums/AlgorithmTypes/SchurAlgorithmType.cs/#L42"><i class="bi bi-code-slash"></i></a>
  </h1>

  <div class="facts text-secondary">
    <dl><dt>Namespace</dt><dd><a class="xref" href="AiDotNet.html">AiDotNet</a>.<a class="xref" href="AiDotNet.Enums.html">Enums</a>.<a class="xref" href="AiDotNet.Enums.AlgorithmTypes.html">AlgorithmTypes</a></dd></dl>
  <dl><dt>Assembly</dt><dd>AiDotNet.dll</dd></dl>
  </div>

  <div class="markdown summary"><p>Represents different algorithm types for computing the Schur decomposition of matrices.</p>
</div>
  <div class="markdown conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public enum SchurAlgorithmType</code></pre>
  </div>









  <h2 id="fields">Fields
</h2>
  <dl class="parameters">
    <dt id="AiDotNet_Enums_AlgorithmTypes_SchurAlgorithmType_Francis"><code>Francis = 0</code></dt>
  <dd><p>Uses the Francis QR algorithm with implicit shifts to compute the Schur decomposition.</p>
<p>
<b>For Beginners:</b> The Francis algorithm is a sophisticated method that efficiently computes the Schur 
decomposition by using clever mathematical shortcuts.
<p>Imagine you're trying to solve a maze: instead of checking every possible path (which would take forever),
you use a strategy that lets you eliminate many paths at once. The Francis algorithm does something similar
with matrices.</p>
<p>The key features of the Francis algorithm:</p>
<ol>
<li><p>It uses &quot;shifts&quot; to accelerate convergence - this means it makes educated guesses about the eigenvalues
and uses these guesses to speed up the process</p>
</li>
<li><p>It works with &quot;bulges&quot; that move through the matrix, gradually transforming it into the desired form</p>
</li>
<li><p>It's much faster than basic QR iteration, especially for large matrices</p>
</li>
<li><p>It's the standard algorithm used in professional numerical libraries</p>
</li>
<li><p>It handles both real and complex matrices efficiently</p>
</li>
</ol>
<p>In machine learning applications, this efficient algorithm enables faster training of models that rely on
eigenvalue decompositions, speeds up covariance matrix analysis in high-dimensional data, and makes certain
types of neural network operations more practical for large-scale problems.</p>

</dd>
  
    <dt id="AiDotNet_Enums_AlgorithmTypes_SchurAlgorithmType_Implicit"><code>Implicit = 1</code></dt>
  <dd><p>Uses an implicit double-shift QR algorithm to compute the Schur decomposition.</p>
<p>
<b>For Beginners:</b> The Implicit algorithm is a variation that focuses on numerical stability and efficiency 
by avoiding explicit calculations of certain intermediate results.
<p>Think of it like mental math: instead of writing down every step when calculating 5×18, you might think
&quot;5×20=100, then subtract 5×2=10, so the answer is 90.&quot; You're implicitly handling the calculation without
explicitly writing out each step.</p>
<p>The Implicit algorithm:</p>
<ol>
<li><p>Reduces roundoff errors by minimizing the number of explicit calculations</p>
</li>
<li><p>Uses mathematical properties to perform multiple operations at once</p>
</li>
<li><p>Is particularly good for matrices with clustered eigenvalues (values that are close together)</p>
</li>
<li><p>Maintains better numerical precision for ill-conditioned problems</p>
</li>
<li><p>Often uses double shifts (handling pairs of eigenvalues at once) for real matrices</p>
</li>
</ol>
<p>In machine learning contexts, this algorithm is valuable when working with sensitive data where small
numerical errors could lead to significantly different results, or when analyzing systems where eigenvalues
are very close together, which happens frequently in certain types of network analysis and signal processing
applications.</p>

</dd>
  
    <dt id="AiDotNet_Enums_AlgorithmTypes_SchurAlgorithmType_QR"><code>QR = 2</code></dt>
  <dd><p>Uses the basic QR iteration algorithm to compute the Schur decomposition.</p>
<p>
<b>For Beginners:</b> The QR algorithm is the fundamental approach to computing the Schur decomposition through 
repeated QR decompositions and recombinations.
<p>Imagine you're kneading dough: you fold it, roll it out, fold it again, and so on. Each time, the dough
gets closer to the consistency you want. The QR algorithm repeatedly transforms the matrix in a similar way,
getting closer to the triangular form with each iteration.</p>
<p>The basic process works like this:</p>
<ol>
<li>Start with your matrix A0</li>
<li>Compute the QR decomposition: A0 = Q1R1</li>
<li>Form a new matrix by multiplying in the reverse order: A1 = R1Q1</li>
<li>Repeat steps 2-3 until the matrix converges to triangular form</li>
</ol>
<p>The QR algorithm:</p>
<ol>
<li><p>Is conceptually simpler than the Francis algorithm</p>
</li>
<li><p>Is easier to implement and understand</p>
</li>
<li><p>Works well for small matrices and educational purposes</p>
</li>
<li><p>Converges more slowly than shifted variants (like Francis)</p>
</li>
<li><p>Provides a good foundation for understanding more advanced methods</p>
</li>
</ol>
<p>In machine learning applications, understanding the basic QR algorithm helps build intuition about how
eigenvalues are computed in practice, which is important when implementing custom algorithms or when
troubleshooting issues related to matrix decompositions in data analysis pipelines.</p>

</dd>
  
  </dl>


  <h2 id="AiDotNet_Enums_AlgorithmTypes_SchurAlgorithmType_remarks">Remarks</h2>
  <div class="markdown level0 remarks"><p>
<b>For Beginners:</b> The Schur decomposition is an important way to break down a square matrix into simpler parts 
that are easier to work with. It's like taking a complex machine and disassembling it into basic components.
<p>Specifically, the Schur decomposition of a matrix A gives you:
A = QTQ*</p>
<p>Where:</p>
<ul>
<li>Q is a unitary matrix (a special kind of matrix where Q* × Q = I, the identity matrix)</li>
<li>T is an upper triangular matrix (has zeros below the diagonal)</li>
<li>Q* is the conjugate transpose of Q (flip the matrix over its diagonal and take complex conjugates)</li>
</ul>
<p>In simpler terms:</p>
<ol>
<li>Q represents a change in coordinate system (like rotating a graph's axes)</li>
<li>T represents a simplified version of the original transformation</li>
<li>Q* represents changing back to the original coordinate system</li>
</ol>
<p>Why is the Schur decomposition important in AI and machine learning?</p>
<ol>
<li><p>Eigenvalue Calculations: It helps find eigenvalues efficiently, which are crucial for techniques like
Principal Component Analysis (PCA)</p>
</li>
<li><p>Matrix Functions: Makes it easier to compute functions of matrices (like matrix exponentials) used in
certain neural network architectures</p>
</li>
<li><p>Stability Analysis: Helps analyze the stability of dynamical systems and recurrent neural networks</p>
</li>
<li><p>Dimensionality Reduction: Contributes to techniques that reduce the complexity of high-dimensional data</p>
</li>
<li><p>Solving Systems: Can be used to efficiently solve certain types of linear systems</p>
</li>
</ol>
<p>This enum specifies which specific algorithm to use for computing the Schur decomposition, as different
methods have different performance characteristics depending on the matrix properties.</p>

</div>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/ooples/AiDotNet/blob/master/src/Enums/AlgorithmTypes/SchurAlgorithmType.cs/#L42" class="edit-link">Edit this page</a>
        </div>


      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          AiDotNet - Enterprise AI/ML Library for .NET
        </div>
      </div>
    </footer>
  </body>
</html>
